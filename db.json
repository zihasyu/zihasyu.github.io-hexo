{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/shoka/source/css/app.styl","path":"css/app.styl","modified":0,"renderable":1},{"_id":"themes/shoka/source/images/404.png","path":"images/404.png","modified":0,"renderable":1},{"_id":"themes/shoka/source/css/comment.styl","path":"css/comment.styl","modified":0,"renderable":1},{"_id":"themes/shoka/source/css/mermaid.styl","path":"css/mermaid.styl","modified":0,"renderable":1},{"_id":"themes/shoka/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/shoka/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/shoka/source/images/alipay.png","path":"images/alipay.png","modified":0,"renderable":1},{"_id":"themes/shoka/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/shoka/source/images/failure.ico","path":"images/failure.ico","modified":0,"renderable":1},{"_id":"themes/shoka/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/shoka/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/shoka/source/images/paypal.png","path":"images/paypal.png","modified":0,"renderable":1},{"_id":"themes/shoka/source/images/play_disc.png","path":"images/play_disc.png","modified":0,"renderable":1},{"_id":"themes/shoka/source/images/play_needle.png","path":"images/play_needle.png","modified":0,"renderable":1},{"_id":"themes/shoka/source/images/wechatpay.png","path":"images/wechatpay.png","modified":0,"renderable":1},{"_id":"themes/shoka/source/images/search.png","path":"images/search.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/24-8-23-chat-note.md","hash":"73877295bf6dcd8e40b6e65014a3e04aa233af69","modified":1724427937312},{"_id":"source/_posts/Feature-based-Delta-Summary.md","hash":"0e2d50a5f3a6f677142d3d2743b463f06312e02f","modified":1722358312222},{"_id":"source/_posts/Summary of Chunking.md","hash":"2dcd7dce81fab33f066a7a7d35d4008c29d28abf","modified":1721897656991},{"_id":"source/_posts/hello-world.md","hash":"acad91ace80b80295b11a9b7ad4c29a2dcfdd8fb","modified":1721656465496},{"_id":"themes/shoka/.gitignore","hash":"bfd7d4c19270c8b349107ffb26f50302943571a9","modified":1721656465498},{"_id":"themes/shoka/.editorconfig","hash":"57f50fc69fdc98a28c9bb04c338865a8b267b4bc","modified":1721656465498},{"_id":"themes/shoka/LICENSE","hash":"1a301f54567fbcd67fc138c37071b96ac9e670a1","modified":1721656465499},{"_id":"themes/shoka/README.md","hash":"162ec0ffef6a69e09c9b00dbc9a8f400b3826fac","modified":1721656465499},{"_id":"themes/shoka/_config.yml","hash":"eaccc7935e0cf4523f82a148b87b89df015f6f4e","modified":1721896888431},{"_id":"themes/shoka/_images.yml","hash":"fd94515a25629f917a7fedeaf08b9ee5a6f75a64","modified":1721656465501},{"_id":"themes/shoka/package.json","hash":"78e368a218a687a4a0d1936fc723e2e6fca2bdfb","modified":1721656465561},{"_id":"themes/shoka/example/_config.shoka.yml","hash":"ab07b1fd050e985e120d0e1797c588c721ac1772","modified":1721656465502},{"_id":"themes/shoka/languages/README.md","hash":"d40601b23836327a36b0d75361f57e95413c50b3","modified":1721656465538},{"_id":"themes/shoka/example/_config.yml","hash":"a6596f241cd5d2e970c025cf927d54ed226e9ec0","modified":1721656465502},{"_id":"themes/shoka/languages/en.yml","hash":"41fb069ee781a9b36be8257627a0f5bd9479cf7f","modified":1721656465539},{"_id":"themes/shoka/example/package.json","hash":"4744a2d23b4558be8932df77989c2ba133f0388e","modified":1721656465504},{"_id":"themes/shoka/languages/default.yml","hash":"da38f00bb45a318f118db0d74df24a137351777e","modified":1721656465538},{"_id":"themes/shoka/languages/zh-CN.yml","hash":"d2cac0184e803ec1947187b23979e24065184ad4","modified":1721656465540},{"_id":"themes/shoka/languages/ja.yml","hash":"579f9e79003eb37a9c68346db0961bff4d9f6a03","modified":1721656465539},{"_id":"themes/shoka/languages/zh-HK.yml","hash":"85a4b1ecd3a36b2e92ebe923495aab1682359e3c","modified":1721656465540},{"_id":"themes/shoka/languages/zh-TW.yml","hash":"060f1886301e9c13241b63c2b5983ebc9f35acaa","modified":1721656465541},{"_id":"themes/shoka/layout/archive.njk","hash":"01847f527849426aab8fcad795597a7076d761fd","modified":1721656465558},{"_id":"themes/shoka/layout/page.njk","hash":"2dac7be8699c8ad6364831eac2ab0167dba7c689","modified":1721656465560},{"_id":"themes/shoka/layout/category.njk","hash":"11a604e3285262d34368b1eb1bf6ff8349c3345f","modified":1721656465559},{"_id":"themes/shoka/layout/index.njk","hash":"561b703a552bf6afaa76a128945a1cc26df3f865","modified":1721656465559},{"_id":"themes/shoka/layout/post.njk","hash":"7213742682ed6c759f6078809b404401ea1784c0","modified":1721656465560},{"_id":"themes/shoka/layout/tag.njk","hash":"f1e9539c178db724961e04bcc08fa94279aae4b1","modified":1721656465561},{"_id":"themes/shoka/layout/_alternate/atom.ejs","hash":"4b40589945713ab19eea69902b0768fc69ec1027","modified":1721656465542},{"_id":"themes/shoka/layout/_macro/breadcrumb.njk","hash":"1dc8ee1de2c20d514c251145d00536d9b0170335","modified":1721656465544},{"_id":"themes/shoka/layout/_alternate/json.ejs","hash":"74975fb6d1ca1099cd843c180ce49353b2061c53","modified":1721656465543},{"_id":"themes/shoka/layout/_alternate/rss.ejs","hash":"bd8df7a85959df3231b0bb617d7b5d05a98c48de","modified":1721656465543},{"_id":"themes/shoka/layout/_macro/card.njk","hash":"0dfd6a2e21119131566f03d7bebedda15d4261b0","modified":1721656465545},{"_id":"themes/shoka/layout/_macro/comment.njk","hash":"fc91ceb0b2c86a38839cef84f50487f119367cd7","modified":1721656465546},{"_id":"themes/shoka/layout/_macro/postmeta.njk","hash":"11e73da9e907e20ea81b920c47265e88fb5d210c","modified":1721656465546},{"_id":"themes/shoka/layout/_macro/sidebar.njk","hash":"7f170b2649f09e88933de4121803990baf5d4022","modified":1721656465547},{"_id":"themes/shoka/layout/_macro/widgets.njk","hash":"1045129c1163e603e9a927161417354758602737","modified":1721656465548},{"_id":"themes/shoka/layout/_macro/segment.njk","hash":"c8e21eeea552c7c685e50252d1983785edc6a29a","modified":1721656465546},{"_id":"themes/shoka/layout/_partials/footer.njk","hash":"4aabeeac4cec09a868aed39282c9d3b3a23e38ba","modified":1721656465549},{"_id":"themes/shoka/layout/_partials/header.njk","hash":"387ac10bedfd79ee30976f5f6ff342b542013b9e","modified":1721657369202},{"_id":"themes/shoka/layout/_partials/pagination.njk","hash":"676ef88ab76d735696f6e8c04338eb3887fb63cc","modified":1721656465552},{"_id":"themes/shoka/layout/_partials/layout.njk","hash":"322cd6927edccbd47eafb63097181ad115a9a4d5","modified":1721658543255},{"_id":"themes/shoka/scripts/filters/locals.js","hash":"63ada9722d96f021f1cd398bbe7bb4991dde1231","modified":1721656465565},{"_id":"themes/shoka/scripts/filters/post.js","hash":"44069b5007b3a692eba70dd9354fc0f4dd27d5ed","modified":1721656465565},{"_id":"themes/shoka/scripts/generaters/archive.js","hash":"a6f87b628f6125cc2614f7214e2ef2995a084663","modified":1721656465566},{"_id":"themes/shoka/scripts/generaters/config.js","hash":"8b9aebab15e192f3a5bc2539ce3aeaddbee98be8","modified":1721656465567},{"_id":"themes/shoka/scripts/helpers/asset.js","hash":"df236860cd91a1c6ffc78ffb4156730d6a59c5d1","modified":1721656465570},{"_id":"themes/shoka/scripts/generaters/images.js","hash":"fcf3d1802c4bb5ff6f2683987f048371e2d00488","modified":1721656465567},{"_id":"themes/shoka/scripts/generaters/index.js","hash":"27b52046c1452b8cb7ca1f64f1eff3d8ad4b0ab6","modified":1721656465568},{"_id":"themes/shoka/scripts/helpers/engine.js","hash":"820a7bb257cab9f7cc5828fe229fa4c3b180fc6a","modified":1721658737800},{"_id":"themes/shoka/scripts/generaters/pages.js","hash":"dd8bb4adec63efa8efc282febd4da989e1523262","modified":1721656465568},{"_id":"themes/shoka/scripts/tags/links.js","hash":"ac5844307e62693a9add08b89d9ec4d6aa5bc25e","modified":1721656465572},{"_id":"themes/shoka/scripts/generaters/script.js","hash":"243e11786081d8d7d5d3b52338925a71c8da8e2c","modified":1721656465569},{"_id":"themes/shoka/scripts/helpers/list_categories.js","hash":"84507e35a428179bd5838fe80d527a9433916391","modified":1721656465571},{"_id":"themes/shoka/scripts/renderer/njk.js","hash":"480f25325494e4caa04794cd496912f628ae2691","modified":1721656465571},{"_id":"themes/shoka/scripts/tags/media.js","hash":"a0f66450f48a1ce0f6c532e687fc3ee85aeed175","modified":1721656465573},{"_id":"themes/shoka/source/css/_iconfont.styl","hash":"05117f95a16e5f7c08351492752994c03f185911","modified":1721656465620},{"_id":"themes/shoka/source/css/_mixins.styl","hash":"68c4bfee20cc6ee477548ce3e4e28e19697d8af3","modified":1721656465621},{"_id":"themes/shoka/source/css/_colors.styl","hash":"6cb23f12441e7517cc614336d867cfa2f35284d7","modified":1721656465574},{"_id":"themes/shoka/source/css/_variables.styl","hash":"c939f1af34a0a8a6a37e6439a8b609a26c9e09d2","modified":1721656465621},{"_id":"themes/shoka/source/css/app.styl","hash":"572d20c4c574b87a2fc49290206c90c8baa7133d","modified":1721656465622},{"_id":"themes/shoka/source/css/mermaid.styl","hash":"ec821a3f997691b92b0926ba4534c94a795ef587","modified":1721656465623},{"_id":"themes/shoka/source/css/comment.styl","hash":"7502a76342c8d84e4a476b35a91fcec22a15cbed","modified":1721656465623},{"_id":"themes/shoka/source/images/404.png","hash":"b7b18f6689d0a14041d87bab6c4e4ce567249d01","modified":1721656465624},{"_id":"themes/shoka/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1721656465625},{"_id":"themes/shoka/source/images/alipay.png","hash":"013436bac325a3a0c2c9b13a08312fc4e7025d69","modified":1721656465625},{"_id":"themes/shoka/source/images/avatar.jpg","hash":"2dc1d96a289ab597b3f5f4c03119191976e2af0a","modified":1721656465627},{"_id":"themes/shoka/source/images/apple-touch-icon.png","hash":"d4e5d65ff663cb71f43515e68d757cbae1ceb3ec","modified":1721656465626},{"_id":"themes/shoka/source/images/paypal.png","hash":"872d4b6d3cacee4845246fbf29817f1ee98bb037","modified":1721656465629},{"_id":"themes/shoka/source/images/failure.ico","hash":"5eec5c163400d8ece74286da49130da1ead3f6f6","modified":1721656465627},{"_id":"themes/shoka/source/images/logo.svg","hash":"830dfbd6dff2986130819f747b25db230b05ca84","modified":1721656465628},{"_id":"themes/shoka/source/images/favicon.ico","hash":"8ae48d9e33b7593cd005aae88b755aa9ce129f0e","modified":1721656465628},{"_id":"themes/shoka/source/images/play_disc.png","hash":"3cfa8dd2e12424c52d1f5e34e9502e446fecde9c","modified":1721656465630},{"_id":"themes/shoka/example/source/_data/colors.styl","hash":"00b06d9366f6a477d02e94eea16bd07aafb7ff2f","modified":1721656465504},{"_id":"themes/shoka/source/images/play_needle.png","hash":"e0998828ab50ce37617f9f4d46b74648206ac852","modified":1721656465630},{"_id":"themes/shoka/source/images/wechatpay.png","hash":"470a42ee16dd516580d5e51607f11dc353a49675","modified":1721656465631},{"_id":"themes/shoka/source/images/search.png","hash":"08c4f6a7a92eff3548aec94b267a23a25e6bd215","modified":1721656465631},{"_id":"themes/shoka/example/source/_data/custom.styl","hash":"d90bc10047d824d73d4f0ba10f81dfe1628558a0","modified":1721656465505},{"_id":"themes/shoka/example/source/_data/iconfont.styl","hash":"b3c284f5bf48ae84d4f016779cf43b67c87e0b87","modified":1721656465506},{"_id":"themes/shoka/example/source/_data/languages.yml","hash":"79b49c2d38c14e29274ebf461fbb3f83ea018fbb","modified":1721656465507},{"_id":"themes/shoka/example/source/_posts/categories.md","hash":"c1ca20b94100a77efc569f43986951a2551f6b64","modified":1721656465508},{"_id":"themes/shoka/example/source/_data/images.yml","hash":"51b822e726990b0b805b24a9041a599cf563ef3f","modified":1721656465507},{"_id":"themes/shoka/example/source/_posts/code-highlight.md","hash":"607f8cf393ad1082398c7f5246e229405bda4de3","modified":1721656465509},{"_id":"themes/shoka/example/source/_posts/elements.md","hash":"66dde9f7cef1c9a90a15776b633c8ab4272ed826","modified":1721656465518},{"_id":"themes/shoka/example/source/_posts/excerpts.md","hash":"9f51babe45d9f45a04d1e6c52eb8a96b58478029","modified":1721656465519},{"_id":"themes/shoka/example/source/_posts/gallery-post.md","hash":"ae577f5171f0354fb0a3702da5bb8ba14372dc28","modified":1721656465520},{"_id":"themes/shoka/example/source/_posts/images.md","hash":"f09b4339b8334584ec311be7e2a2e7e839bcfa04","modified":1721656465521},{"_id":"themes/shoka/example/source/_posts/hello-world.md","hash":"ceb583413b760182a3c2463bf7f15c03328a37bc","modified":1721656465520},{"_id":"themes/shoka/example/source/_posts/link-post-without-title.md","hash":"811e7ec6f4ed747388e8255b27e482d04b304c51","modified":1721656465521},{"_id":"themes/shoka/example/source/_posts/markdown.md","hash":"7b03cdab8abff7010603ad0e66ef611564e08694","modified":1721656465523},{"_id":"themes/shoka/example/source/_posts/link-post.md","hash":"ac9a280178ba63ccc3acc7540aa96db4d08b5b21","modified":1721656465522},{"_id":"themes/shoka/example/source/_posts/long-title.md","hash":"e11f04c88e453b6b265d634458a69d0124edc684","modified":1721656465522},{"_id":"themes/shoka/example/source/_posts/no-title.md","hash":"24536a15b2a9633d0a4dfad66c0ab51a683d78b5","modified":1721656465523},{"_id":"themes/shoka/example/source/_posts/tag-plugins.md","hash":"35e8c2ca9e48d5653f8d69ef05a0221c1b207e4e","modified":1721656465524},{"_id":"themes/shoka/example/source/_posts/tags.md","hash":"788411e01f179f65bc6ea61c73601a0a4a1072d0","modified":1721656465524},{"_id":"themes/shoka/example/source/_posts/videos.md","hash":"32735a9b9f0370d49e0f4311c8bc1fbcfba98445","modified":1721656465525},{"_id":"themes/shoka/example/source/friends/_data.yml","hash":"1b090bd2f25f4d00471f31c4136141d4ad1ae19a","modified":1721656465536},{"_id":"themes/shoka/example/source/_posts/日本語テスト.md","hash":"5ae9b45f038baa96bd179b4ad0b03409e9a76bdb","modified":1721656465526},{"_id":"themes/shoka/example/source/_posts/中文測試.md","hash":"0dd7c0e2e2242939b69dd6d66fe28f56b69ff65a","modified":1721656465525},{"_id":"themes/shoka/example/source/friends/index.md","hash":"c44fdf47aae95588c686a15fa2046ab9a4c09b9b","modified":1721656465537},{"_id":"themes/shoka/layout/_partials/post/copyright.njk","hash":"b6aa82c28683bdb337920db718841bee207dc2d9","modified":1721656465553},{"_id":"themes/shoka/layout/_partials/third-party/baidu-analytics.njk","hash":"9f4568ede657e6844fe54e3cdf9635ecd94b2bf9","modified":1721656465558},{"_id":"themes/shoka/layout/_partials/head/head_unique.njk","hash":"afb09eeda0de5dd4df67ba80b58b9ace9eaf5e0d","modified":1721656465550},{"_id":"themes/shoka/layout/_partials/post/nav.njk","hash":"01e49cc56aa8722f0eb2739ce2e55080429e576e","modified":1721656465554},{"_id":"themes/shoka/layout/_partials/head/head.njk","hash":"6da240090ef220d6917ea92a1187987c38654097","modified":1721656465550},{"_id":"themes/shoka/layout/_partials/post/reward.njk","hash":"f7185a561288a754beae1323a19c200b99dccd08","modified":1721656465555},{"_id":"themes/shoka/layout/_partials/sidebar/overview.njk","hash":"3c12aa376662f15366177792a35873f2344152b8","modified":1721656465557},{"_id":"themes/shoka/layout/_partials/sidebar/menu.njk","hash":"14192d78b637ca07ec4a0505268bfaecca2f0680","modified":1721656465556},{"_id":"themes/shoka/layout/_partials/post/footer.njk","hash":"8e7cae0c45bbc2cf3e91eac10ab319caa6b27d2e","modified":1721656465553},{"_id":"themes/shoka/source/js/_app/dom.js","hash":"1bd152fc94f33793e71cada5ec8bbfd71e531d6c","modified":1721656465633},{"_id":"themes/shoka/source/js/_app/fireworks.js","hash":"e4bf5a9955618bb43020e175e59e497b28c78131","modified":1721656465633},{"_id":"themes/shoka/layout/_partials/post/post.njk","hash":"e1846d51aca86c873f1c74152b80d50eec79507b","modified":1721656465554},{"_id":"themes/shoka/source/js/_app/global.js","hash":"a792824837bcf9cb90ec2c831dea2dc4de85cbf1","modified":1721656465634},{"_id":"themes/shoka/source/js/_app/page.js","hash":"d8a51bdd02bc839290df4ea9708a3e1cf39a823a","modified":1721656465635},{"_id":"themes/shoka/source/js/_app/pjax.js","hash":"0528d97ad162eb9f70e21540d993d48e6027ba2d","modified":1721656465635},{"_id":"themes/shoka/source/js/_app/player.js","hash":"d49cc563b239659d554c838f784af8244023f886","modified":1721656465636},{"_id":"themes/shoka/source/js/_app/sidebar.js","hash":"1d532138431e98e28f7579a52b0e88909aba76e0","modified":1721656465636},{"_id":"themes/shoka/source/css/_common/outline/outline.styl","hash":"e107c799b88278db84a2d5a8819d17f48511f73e","modified":1721656465606},{"_id":"themes/shoka/source/css/_common/outline/mobile.styl","hash":"15c7be9e4e1b3c6b55e7beef5685898ae4f846ab","modified":1721656465606},{"_id":"themes/shoka/source/js/_app/utils.js","hash":"6e123d054bf003deb4fc5eb80cfec233e4941851","modified":1721656465637},{"_id":"themes/shoka/source/css/_common/components/components.styl","hash":"3677ba4471475026d232e3af00d5e6de027151e6","modified":1721656465576},{"_id":"themes/shoka/source/css/_common/scaffolding/animate.styl","hash":"dda625de5efb0e5b53e81c9da053850e9767da22","modified":1721656465613},{"_id":"themes/shoka/source/css/_common/scaffolding/buttons.styl","hash":"555c4b09c9970931e73abe544ae6356cf870670e","modified":1721656465614},{"_id":"themes/shoka/source/css/_common/scaffolding/base.styl","hash":"415635fa6f145a53a10fa7f0b72247747530f9e7","modified":1721656465614},{"_id":"themes/shoka/source/css/_common/scaffolding/divider.styl","hash":"faa2e60cafdb0379f66a9ff7f9bd8e4d53551882","modified":1721656465615},{"_id":"themes/shoka/source/css/_common/scaffolding/iconfont.styl","hash":"b3c284f5bf48ae84d4f016779cf43b67c87e0b87","modified":1721656465615},{"_id":"themes/shoka/source/css/_common/scaffolding/normalize.styl","hash":"eea39861e6cb0cdc0e26d2f7878c2059991d3d40","modified":1721656465616},{"_id":"themes/shoka/source/css/_common/scaffolding/pagination.styl","hash":"80bb3542fb6c7245f9f559c97938a65d29a61784","modified":1721656465617},{"_id":"themes/shoka/source/css/_common/scaffolding/ribbon.styl","hash":"e9c99fbd15cb9b118091d6e9add6aaf2abd8ab7d","modified":1721656465617},{"_id":"themes/shoka/source/css/_common/scaffolding/scaffolding.styl","hash":"14295140c2e5e50545a9b8404839589d486d78c9","modified":1721656465618},{"_id":"themes/shoka/source/css/_common/scaffolding/tables.styl","hash":"a67472f2b36047f5f1c2d85e398afe5003e06087","modified":1721656465619},{"_id":"themes/shoka/source/css/_common/scaffolding/scrollbar.styl","hash":"f34503ae1dce5bfc964d52f3f22601058fc7a907","modified":1721656465618},{"_id":"themes/shoka/source/css/_common/scaffolding/tip.styl","hash":"ffdfdc91b9d29060a36bfdf92b746596fd05afd9","modified":1721656465619},{"_id":"themes/shoka/source/css/_common/outline/header/brand.styl","hash":"6335d84443326d19fff8e17f364d4cace8f19445","modified":1721656465602},{"_id":"themes/shoka/source/css/_common/outline/footer/footer.styl","hash":"66592076afe7b86b7962aac5451e0b5248d7172e","modified":1721656465601},{"_id":"themes/shoka/source/css/_common/scaffolding/toggles.styl","hash":"a71d609401001c9b15608d5276636180d49cf844","modified":1721656465620},{"_id":"themes/shoka/example/source/_posts/computer-science/note/cover.jpg","hash":"6d077a7330284d0fb2b79e96d7e5b56121395df3","modified":1721656465514},{"_id":"themes/shoka/example/source/_posts/computer-science/note/theme-shoka-doc.md","hash":"cd2c1d52df850bd7e8cc130bfb19ae6a5fc97f25","modified":1721656465515},{"_id":"themes/shoka/source/css/_common/outline/header/header.styl","hash":"ca7f94ebb0f3090405aab79889b81d4e708a6ab6","modified":1721656465602},{"_id":"themes/shoka/source/css/_common/outline/header/image.styl","hash":"0777d91cbc7e228426c46ee97627a32054526013","modified":1721656465603},{"_id":"themes/shoka/source/css/_common/outline/header/nav.styl","hash":"b267a98cfee639dad82e0889b29ac5bee2634ab6","modified":1721656465604},{"_id":"themes/shoka/source/css/_common/outline/header/menu.styl","hash":"3b309ade55860b4d8c693b336a33e470436a32b7","modified":1721656465603},{"_id":"themes/shoka/source/css/_common/outline/header/right.styl","hash":"d9a7f9923ea7ad2b3aeda9ce7140697f9d094054","modified":1721656465604},{"_id":"themes/shoka/source/css/_common/outline/header/tool.styl","hash":"1fa043670ba8cc2a4c86081e5dd88e9ed4b1f978","modified":1721656465605},{"_id":"themes/shoka/source/css/_common/outline/sidebar/author.styl","hash":"a09b34b35d31a4b8e275bfbb92efa48fe6608d2f","modified":1721656465607},{"_id":"themes/shoka/source/css/_common/outline/sidebar/dimmer.styl","hash":"66f159f21cafe1dc71570f7018678a0a3862c175","modified":1721656465608},{"_id":"themes/shoka/source/css/_common/outline/header/waves.styl","hash":"f9e6ae9e36429568c0323a112f39d6ea2baaefd6","modified":1721656465605},{"_id":"themes/shoka/source/css/_common/outline/sidebar/related.styl","hash":"e300d2ec33fb7bfbc9310578b8891eb6cd137e86","modified":1721656465610},{"_id":"themes/shoka/source/css/_common/outline/sidebar/menu.styl","hash":"46df47361148673e6c2ce114b4f498be63c0e4ab","modified":1721656465608},{"_id":"themes/shoka/source/css/_common/outline/sidebar/quick.styl","hash":"01b34ce24ad3dde1147c8f3a6babd70e3d45b461","modified":1721656465609},{"_id":"themes/shoka/source/css/_common/outline/sidebar/sidebar.styl","hash":"6a1a13ecc6de3ceba1957f95aa852d440abaae9b","modified":1721656465610},{"_id":"themes/shoka/source/css/_common/outline/sidebar/social.styl","hash":"33f6459f44e15ef3320e3b208e5345ff1d0cee5f","modified":1721656465611},{"_id":"themes/shoka/source/css/_common/outline/sidebar/state.styl","hash":"c2eaaba4c35df5253ae236318b5e6f76861d37f8","modified":1721656465611},{"_id":"themes/shoka/source/css/_common/outline/sidebar/toc.styl","hash":"5836be92d4d153bd44ff86fe05e0ce83b11ae569","modified":1721656465612},{"_id":"themes/shoka/source/css/_common/outline/sidebar/tab.styl","hash":"b6f604f7293230d0113dabe5deeb61b809fdf035","modified":1721656465612},{"_id":"themes/shoka/source/css/_common/components/highlight/operation.styl","hash":"f2ac0660d8f9e4d4582a4a8c4f97bd6d80162a6d","modified":1721656465577},{"_id":"themes/shoka/source/css/_common/components/pages/home.styl","hash":"95ad71e89df31b58e9db37b4b0c092f2102f91b2","modified":1721656465578},{"_id":"themes/shoka/source/css/_common/components/pages/collapse.styl","hash":"a0ecc9afe8c03eae06075fc53c39057e05d22b1e","modified":1721656465578},{"_id":"themes/shoka/source/css/_common/components/highlight/highlight.styl","hash":"18be598f5f1d75cb4869adcd1ae47bd19456b2c5","modified":1721656465576},{"_id":"themes/shoka/source/css/_common/components/post/breadcrumb.styl","hash":"43f7a0d6c7f7bde6a4e521acb67a5b0543a12b77","modified":1721656465580},{"_id":"themes/shoka/source/css/_common/components/post/copyright.styl","hash":"0a3991a291b53301c6a3f5a86532ea75b8acf355","modified":1721656465581},{"_id":"themes/shoka/source/css/_common/components/pages/pages.styl","hash":"e2af0d359247a82dab6f8d6ce90d6b0d5fca4dc9","modified":1721656465579},{"_id":"themes/shoka/source/css/_common/components/pages/tag-cloud.styl","hash":"2ebc481064dae0b593e8caff838044f92a5e2ef7","modified":1721656465579},{"_id":"themes/shoka/source/css/_common/components/post/expand.styl","hash":"ecd24e46405f6e2f08394d7e1e65c86b9294642f","modified":1721656465582},{"_id":"themes/shoka/source/css/_common/components/post/post.styl","hash":"510d1f7457c2191f8a7bd84ce79cc3c0aade44a8","modified":1721656465584},{"_id":"themes/shoka/source/css/_common/components/post/footer.styl","hash":"256f45905d0d1b17d74b6cbfebdc5ef7a107ed83","modified":1721656465582},{"_id":"themes/shoka/source/css/_common/components/post/nav.styl","hash":"7c8f1bf2c755b8c3d1a41eaf1aa6f59d3c23a4a2","modified":1721656465583},{"_id":"themes/shoka/source/css/_common/components/post/header.styl","hash":"b1b13db6e10a9b46fbd052dc4db1aa1cfb97ab97","modified":1721656465583},{"_id":"themes/shoka/source/css/_common/components/tags/collapse.styl","hash":"aa663a0fcee4138be9a3272172cd30b8118261df","modified":1721656465586},{"_id":"themes/shoka/source/css/_common/components/post/rtl.styl","hash":"4a431ec0b382ae6693f1aee54599da18eddc6a59","modified":1721656465585},{"_id":"themes/shoka/source/css/_common/components/post/tags.styl","hash":"e3348bf77b141068b91181655945277d6270312b","modified":1721656465585},{"_id":"themes/shoka/source/css/_common/components/post/reward.styl","hash":"897a0a0e37ed23ef8ca6c644b3794cf8c32f1650","modified":1721656465584},{"_id":"themes/shoka/source/css/_common/components/tags/label.styl","hash":"dff26da9be9a7304780941b95d144d03e6b7b19b","modified":1721656465587},{"_id":"themes/shoka/source/css/_common/components/tags/container.styl","hash":"541d71873e36373b671a7cec61ac10db48413d9f","modified":1721656465586},{"_id":"themes/shoka/source/css/_common/components/tags/links.styl","hash":"2732062ecaf3a5fec24442bf2fc25de7f4279ff9","modified":1721656465588},{"_id":"themes/shoka/source/css/_common/components/tags/note.styl","hash":"0eb5410344a0e4506b641689d6835ea8929553e8","modified":1721656465589},{"_id":"themes/shoka/source/css/_common/components/tags/list.styl","hash":"53ceac76fcaa1353cae910e80449810be0cc4254","modified":1721656465588},{"_id":"themes/shoka/source/css/_common/components/tags/player.styl","hash":"f182dad19b6cc575a1631713a00fd7f0d4516c19","modified":1721656465589},{"_id":"themes/shoka/source/css/_common/components/tags/quiz.styl","hash":"cc0fbb250fdf00887c043e41f0cb777f4f46f992","modified":1721656465590},{"_id":"themes/shoka/source/css/_common/components/tags/tabs.styl","hash":"950cb00307208fbb332119796c4a1ac850f19941","modified":1721656465590},{"_id":"themes/shoka/source/css/_common/components/tags/tags.styl","hash":"b353f2dfc373508d0e0c798bd22107f63591054f","modified":1721656465591},{"_id":"themes/shoka/source/css/_common/components/third-party/loading.styl","hash":"dc513c323ac3555a94e96809d57d09bc4d65fc2b","modified":1721656465592},{"_id":"themes/shoka/source/css/_common/components/third-party/search.styl","hash":"33b29d3782f058f2b8b89deb3f738fda2517ca4c","modified":1721656465597},{"_id":"themes/shoka/source/css/_common/components/third-party/pace.styl","hash":"c93cb3a4715394f8a35db9bb65e03aea8bda45da","modified":1721656465597},{"_id":"themes/shoka/source/css/_common/components/third-party/theme.styl","hash":"2d112448cc435b58c57ebd9b31e016e6ae8af5d0","modified":1721656465598},{"_id":"themes/shoka/example/source/_posts/computer-science/java/course-1/cover.jpg","hash":"57341ddf90eeb71d0b9a3fef8cf1f094f9c299b3","modified":1721656465511},{"_id":"themes/shoka/source/css/_common/components/third-party/third-party.styl","hash":"68ee764bfb8bb0bb478cd41c78895dd341600d26","modified":1721656465598},{"_id":"themes/shoka/source/css/_common/components/third-party/valine.styl","hash":"59c69ea7817c0348872f865d406b9650814279ce","modified":1721656465599},{"_id":"themes/shoka/source/css/_common/components/third-party/widgets.styl","hash":"71fe298ba9de676ebc3c00febe10784aa7dc119a","modified":1721656465599},{"_id":"themes/shoka/example/source/_posts/computer-science/java/course-1/week-1.md","hash":"8284465659be7a4b7568244264bc236c01a6d1cb","modified":1721656465512},{"_id":"themes/shoka/example/source/_posts/computer-science/note/theme-shoka-doc/config.md","hash":"19c4015857b6953da18628967b7a0b84e624a43d","modified":1721656465516},{"_id":"themes/shoka/source/css/_common/components/third-party/mermaid/class.styl","hash":"0d9b0d1d2ecf981b881e9416fc770d47f679a50f","modified":1721656465593},{"_id":"themes/shoka/example/source/_posts/computer-science/note/theme-shoka-doc/dependents.md","hash":"5048e40092f39f776060e083c822698e5842a3ea","modified":1721656465516},{"_id":"themes/shoka/example/source/_posts/computer-science/note/theme-shoka-doc/special.md","hash":"3c0c0bf6b7cd1ab3c12e0d097330937a2803ed10","modified":1721656465518},{"_id":"themes/shoka/example/source/_posts/computer-science/note/theme-shoka-doc/display.md","hash":"fce410e8e5756ea256c6a23ee688455bb8d51e93","modified":1721656465517},{"_id":"themes/shoka/example/source/_posts/computer-science/java/course-1/week-2.md","hash":"5efffda6c8abc24a1d4671c54928cfe7fb838ce5","modified":1721656465513},{"_id":"themes/shoka/source/css/_common/components/third-party/mermaid/flowchart.styl","hash":"83296761c85b8e82d0757b1a4792a74d50509d2d","modified":1721656465593},{"_id":"themes/shoka/source/css/_common/components/third-party/mermaid/gantt.styl","hash":"bae6617a32026891f510483aa6d25c70a82c5945","modified":1721656465594},{"_id":"themes/shoka/source/css/_common/components/third-party/mermaid/git.styl","hash":"a7e5f3bb9378b1a4fb0f710e28a02fd4fd1b3040","modified":1721656465594},{"_id":"themes/shoka/source/css/_common/components/third-party/mermaid/mermaid.styl","hash":"e54378b88ce839626bdbcb00676d79dbe70a742c","modified":1721656465595},{"_id":"themes/shoka/source/css/_common/components/third-party/mermaid/pie.styl","hash":"bce4029a87d60ba40ff4faadb9d95c76b824141a","modified":1721656465595},{"_id":"themes/shoka/source/css/_common/components/third-party/mermaid/sequence.styl","hash":"7e91e07c39e1c1343626c8d5b9fecfebc6c086f6","modified":1721656465596},{"_id":"themes/shoka/source/css/_common/components/third-party/mermaid/state.styl","hash":"83d21d840bd2bc4249e2dced49efe8cef2281f05","modified":1721656465596},{"_id":"themes/shoka/example/source/assets/wallpaper-2572384.jpg","hash":"1df3620ab8c69fe2498a746f8ead057162df0637","modified":1721656465531},{"_id":"themes/shoka/screenshot.png","hash":"676ab8bfe3fa106e5b88617ab377cd6b438cc0d9","modified":1721656465563},{"_id":"themes/shoka/example/source/assets/wallpaper-878514.jpg","hash":"9f9705a377c42320b335b3c66b023e62b80e56e3","modified":1721656465535},{"_id":"themes/shoka/example/source/assets/wallpaper-2311325.jpg","hash":"ddaaaeb4fa04a05c83053c1f8149720d18c9c8de","modified":1721656465529},{"_id":"public/rss.xml","hash":"9e6d66a24a06f0fecad64258388c4547719429ab","modified":1724427942037},{"_id":"public/feed.json","hash":"ebfad922366d08b6a1f84081e17afb2118deb7d5","modified":1724427942037},{"_id":"public/atom.xml","hash":"ea53463b67f248d3e09833b00404e2387b2e382c","modified":1724427942037},{"_id":"public/js/app.js","hash":"bd0fcfa7c2fd9e97bfd7b744db7acc818276e309","modified":1724427942037},{"_id":"public/2024/07/22/hello-world/index.html","hash":"094bc4edcb0a8b797435f26938e5e0d1448dd15f","modified":1724427942037},{"_id":"public/20204/08/23/24-8-23-chat-note/index.html","hash":"b21033fd027996b666880038a216a53e59eb2cfe","modified":1724427942037},{"_id":"public/2024/07/31/Feature-based-Delta-Summary/index.html","hash":"bc7980b88e9bfa22fde4cad061a1ba99def47231","modified":1724427942037},{"_id":"public/2024/07/04/Summary of Chunking/index.html","hash":"4920d1c2d18c27dce68ec0c32a6c1ba2161bd973","modified":1724427942037},{"_id":"public/categories/Compression-algorithms/index.html","hash":"2a9f6a41de0c161adec70db360057d67844fc8dd","modified":1724427942037},{"_id":"public/categories/Compression-algorithms/chat-note/index.html","hash":"e7d825b0c4e2e119a5c25f257bb7d297a2f343d3","modified":1724427942037},{"_id":"public/tags/Compression/index.html","hash":"270d58c2fcecbab5d9249bcf1c6c197cd30650b4","modified":1724427942037},{"_id":"public/tags/Storage-system/index.html","hash":"df15b6e1d8bce0c98c36b1a97615a064f7a0379d","modified":1724427942037},{"_id":"public/tags/Feature-based/index.html","hash":"585d77b033115b67b788596fc48656fd5aa08bfd","modified":1724427942037},{"_id":"public/tags/Operating-system/index.html","hash":"436fe7646b123b084a032a8c85a0bb82fc10e090","modified":1724427942037},{"_id":"public/tags/Computer-science/index.html","hash":"be4b595d2fd0c0e8b06c1430d4c233d87ce7c9c6","modified":1724427942037},{"_id":"public/tags/Chunking/index.html","hash":"32d9319a7518b5683f1a674961ef25c7102e4455","modified":1724427942037},{"_id":"public/archives/index.html","hash":"c03aa5e82688386079fdff6075ecfb2be55be149","modified":1724427942037},{"_id":"public/archives/2024/07/index.html","hash":"4cb62dc1d14ae0c8d6394ccd9c5f6690879dfdd5","modified":1724427942037},{"_id":"public/archives/2024/index.html","hash":"26b04635302531217c64d5b69f3039c66e38030b","modified":1724427942037},{"_id":"public/archives/20204/index.html","hash":"03de6de8484ca6d404f0c3655d9c5c781e9a8bce","modified":1724427942037},{"_id":"public/archives/20204/08/index.html","hash":"3b786ff619b4c773578fc37adf08ad6f18b92ac2","modified":1724427942037},{"_id":"public/categories/index.html","hash":"1318cbb86cbab192b6471947f2bce5c75f4f49a7","modified":1724427942037},{"_id":"public/tags/index.html","hash":"cbee4552c2d206ffc46d09c8f931e7dcb9085ff1","modified":1724427942037},{"_id":"public/404.html","hash":"04441c6a29e6a22724ae3f4b74c63f41a1709389","modified":1724427942037},{"_id":"public/index.html","hash":"cfc0cec2aa96b3b226530033707d9a46436a1b57","modified":1724427942037},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1724427942037},{"_id":"public/images/404.png","hash":"b7b18f6689d0a14041d87bab6c4e4ce567249d01","modified":1724427942037},{"_id":"public/images/apple-touch-icon.png","hash":"d4e5d65ff663cb71f43515e68d757cbae1ceb3ec","modified":1724427942037},{"_id":"public/images/alipay.png","hash":"013436bac325a3a0c2c9b13a08312fc4e7025d69","modified":1724427942037},{"_id":"public/images/avatar.jpg","hash":"2dc1d96a289ab597b3f5f4c03119191976e2af0a","modified":1724427942037},{"_id":"public/images/failure.ico","hash":"5eec5c163400d8ece74286da49130da1ead3f6f6","modified":1724427942037},{"_id":"public/images/logo.svg","hash":"830dfbd6dff2986130819f747b25db230b05ca84","modified":1724427942037},{"_id":"public/images/favicon.ico","hash":"8ae48d9e33b7593cd005aae88b755aa9ce129f0e","modified":1724427942037},{"_id":"public/images/play_disc.png","hash":"3cfa8dd2e12424c52d1f5e34e9502e446fecde9c","modified":1724427942037},{"_id":"public/images/play_needle.png","hash":"e0998828ab50ce37617f9f4d46b74648206ac852","modified":1724427942037},{"_id":"public/images/paypal.png","hash":"872d4b6d3cacee4845246fbf29817f1ee98bb037","modified":1724427942037},{"_id":"public/images/wechatpay.png","hash":"470a42ee16dd516580d5e51607f11dc353a49675","modified":1724427942037},{"_id":"public/images/search.png","hash":"08c4f6a7a92eff3548aec94b267a23a25e6bd215","modified":1724427942037},{"_id":"public/css/app.css","hash":"e8c04eaf6ae124837564304f6da969fff3082844","modified":1724427942037},{"_id":"public/css/comment.css","hash":"6e5b37bce0723d8cf30d4a41fdac6c9135b1d598","modified":1724427942037},{"_id":"public/css/mermaid.css","hash":"54b6c75332e23471f85d828de6ef80feb9b3f0a7","modified":1724427942037}],"Category":[{"name":"Compression algorithms","_id":"cm06vvh0z000224un648u9lrq"},{"name":"chat note","parent":"cm06vvh0z000224un648u9lrq","_id":"cm06vvh13000624un82g332ev"}],"Data":[],"Page":[],"Post":[{"title":"chat-note:Data Compression & Data Deduplication","date":"+020204-08-23T15:39:40.000Z","_content":"#### Q1: Why is there such a significant difference between Huffman-type compression and post-chunking compression? Are they considered separate fields? What are their connections and differences?\n```\n我看信息论及其衍生出来的压缩方法都强调distance，例如窗口大小为32K时，他最多用distance为32576的字符串来去重。去重后再进行huffman编码来减少存储开销。  \n而在备份系统中因为chunking的存在，没有distance这个限制，完全可以与几百GiB之前的数据块进行压缩，但相应的chunking后的压缩算法需要recipe来记录源数据（用来解压）。  \n那么请问，为什么huffman编码类压缩和chunking后压缩区别如此大呢，这是否算是两个领域，有什么联系与区别\n```\n#### A1:\n```\n您提出了一个非常深刻的问题，这涉及到传统压缩算法和现代备份系统中数据去重技术的本质区别。让我们逐步分析这两种方法的特点、区别和联系：\n\n1. 传统压缩算法（如DEFLATE，使用在gzip中）\n\n特点：\n- 使用滑动窗口（通常为32KB）\n- 局部去重（LZ77算法）\n- Huffman编码减少冗余\n\n优势：\n- 单遍处理，内存需求小\n- 压缩和解压速度快\n- 不需要额外的元数据（除了很小的头部信息）\n\n限制：\n- 只能利用局部的重复性（32KB窗口内）\n- 压缩率受限于窗口大小\n\n2. 基于Chunking的备份系统压缩\n\n特点：\n- 全局去重\n- 可以引用任何之前见过的数据块\n- 需要额外的recipe来记录数据引用\n\n优势：\n- 可以利用全局的数据重复性\n- 对于有大量重复数据的场景（如备份），压缩率极高\n- 可以实现增量备份和快速恢复\n\n限制：\n- 需要维护大量元数据（recipe）\n- 通常需要更多的内存和存储空间来管理元数据\n- 压缩和解压可能更慢，尤其是随机访问时\n\n区别和联系：\n\n1. 范围差异：\n   传统压缩关注局部优化，而chunking关注全局优化。\n\n2. 使用场景：\n   传统压缩适用于单个文件或流，chunking更适合大规模存储系统。\n\n3. 元数据开销：\n   传统压缩几乎没有额外元数据，chunking需要大量元数据。\n\n4. 可扩展性：\n   chunking在数据量增加时可以保持高效，而传统压缩效率可能下降。\n\n5. 计算复杂度：\n   传统压缩通常计算复杂度较低，chunking可能需要更复杂的处理。\n\n6. 理论基础：\n   两者都基于信息论，但应用方式不同。传统压缩更直接应用熵编码，chunking更关注冗余消除。\n\n联系：\n\n1. 两种方法都试图利用数据的冗余性。\n2. 在某些系统中，这两种方法可以结合使用：先进行全局去重，然后对unique chunks应用传统压缩。\n3. 都受益于信息论的理论指导，如熵编码和冗余消除。\n\n为什么区别如此大：\n\n1. 设计目标不同：传统压缩针对单个文件优化，chunking针对大规模存储系统优化。\n2. 技术发展：chunking利用了现代系统更大的内存和存储能力。\n3. 应用场景：备份系统面临的数据特性（大量重复）与单个文件压缩不同。\n\n这两种方法确实可以视为压缩领域的两个不同分支，但它们有共同的理论基础，并且在现代系统中常常结合使用。选择哪种方法或如何结合，取决于具体的应用场景、系统资源和性能需求。\n\n如果您想深入了解这两种方法的某个具体方面，或者探讨它们在特定场景下的应用，我可以提供更详细的分析。\n```\n#### Q2: What are the primary application scenarios for chunking methods and traditional compression methods respectively?\n```\n所以只有备份系统场景下，才会需要chunking吗，压缩单个文件更倾向于使用LZ77+huffman这种传统方法?\n```\n#### A2\n```您的观察非常准确，但实际情况略微复杂一些。让我们深入探讨一下：\n\n1. 备份系统和Chunking\n\n确实，备份系统是Chunking技术最广泛和最有效的应用场景之一。原因包括：\n- 大量重复数据\n- 需要增量备份\n- 快速恢复的需求\n\n2. 单个文件压缩\n\n对于单个文件压缩，传统的LZ77+Huffman（如DEFLATE算法）确实是最常用的方法。原因包括：\n- 速度快\n- 内存需求低\n- 压缩率适中\n- 广泛兼容性\n\n3. Chunking在其他场景的应用\n\n然而，Chunking并不仅限于备份系统。它在其他场景也有应用：\n\na) 大型文件存储系统：\n   - 例如：Dropbox, Google Drive 等云存储服务\n   - 利用跨用户的数据重复性\n\nb) 内容分发网络（CDN）：\n   - 利用Chunking实现高效的内容更新和传输\n\nc) 版本控制系统：\n   - 如Git，使用类似Chunking的方法来高效存储文件的不同版本\n\nd) 大数据处理：\n   - 在某些大数据处理框架中，Chunking用于数据分割和去重\n\ne) 虚拟机镜像管理：\n   - 利用Chunking来高效存储和传输VM镜像\n\n4. 单文件压缩的新发展\n\n即使对于单文件压缩，也有一些新的发展借鉴了Chunking的思想：\n\na) LZMA（用在7z）：\n   - 使用更大的字典大小，接近全局去重的效果\n\nb) Zstandard：\n   - 提供大字典支持，可以利用更广范围的重复性\n\nc) 基于机器学习的压缩：\n   - 如Google的Gipfeli，尝试在单文件中识别和利用更广泛的模式\n\n5. 选择压缩方法的考虑因素\n\n选择使用传统方法还是Chunking（或其变体）取决于多个因素：\n\n- 数据规模\n- 重复模式（局部vs全局）\n- 压缩/解压速度要求\n- 随机访问需求\n- 存储和计算资源限制\n- 兼容性需求\n\n6. 混合方法\n\n在一些高级系统中，会结合使用这两种方法：\n- 首先使用Chunking进行全局去重\n- 然后对unique chunks使用传统压缩方法进一步压缩\n\n结论：\n虽然单文件压缩确实更倾向于使用传统方法，但Chunking的思想已经渗透到了更广泛的应用中。现代压缩技术正在不断融合这两种方法的优点，以适应不同的应用场景和数据特性。\n\n选择合适的方法需要深入理解数据特性和应用需求。在某些情况下，混合使用或选择专门设计的算法可能会带来更好的性能。\n\n如果您对某个特定场景或应用有更具体的问题，我很乐意提供更详细的分析和建议。\n```\n---\n#### Q3: Does Shannon's compression limit only apply to traditional local compression and Huffman coding?\n```\n我可以认为香农压缩极限只作用于传统的localcompression+huffman吗\n```\n#### A3:\n```\n这个问题触及了信息论的核心概念和其在不同压缩方法中的应用。让我们深入探讨一下：\n\n1. 香农压缩极限的普适性\n\n首先，需要明确的是，香农压缩极限（或香农熵）是一个普适的概念，适用于所有形式的无损数据压缩，不仅限于传统的局部压缩+Huffman编码。香农熵定义了在给定概率分布下，编码信息所需的理论最小平均比特数。\n\n2. 传统局部压缩+Huffman编码\n\n传统方法（如LZ77+Huffman）确实直接使用了香农压缩极限的概念：\n- LZ77利用局部重复性减少冗余\n- Huffman编码试图接近给定概率分布的熵\n\n这些方法在局部范围内（如32KB窗口）尝试接近香农极限。\n\n3. Chunking和全局去重\n\nChunking和全局去重虽然看起来与传统方法很不同，但它们同样受香农压缩极限的约束：\n\n- 理论基础：这些方法本质上是在更大的范围内寻找和消除冗余，这与熵的概念是一致的。\n\n- 全局优化：通过在更大范围内去重，这些方法实际上在尝试接近更大数据集的真实熵。\n\n- Recipe的作用：Recipe（或元数据）本质上是一种编码，其效率同样受熵的限制。\n\n4. 香农极限在不同尺度上的应用\n\n- 局部尺度：传统压缩在小范围内优化\n- 全局尺度：Chunking在更大范围内优化\n- 两者都在各自的尺度上试图接近香农极限\n\n5. 理解的关键点\n\n- 信息源模型：香农极限假设了一个特定的信息源模型。不同的压缩方法可能隐含地假设了不同的模型。\n\n- 计算复杂性：香农极限不考虑计算复杂性，而实际方法必须在效率和压缩率之间权衡。\n\n- 上下文和依赖：更复杂的方法（如Chunking）可能能够捕捉更多的上下文和长程依赖，从而在理论上更接近真实的熵。\n\n6. 结论\n\n因此，我们不能说香农压缩极限只作用于传统的局部压缩+Huffman方法。实际上：\n\n- 香农压缩极限适用于所有无损压缩方法。\n- 不同的方法在不同的尺度和假设下尝试接近这个极限。\n- Chunking和全局去重可以看作是在更大范围内应用熵编码原理的尝试。\n- 所有这些方法都受到信息论原理的指导，只是应用方式和范围不同。\n\n理解这一点很重要，因为它帮助我们认识到，无论是传统方法还是现代的全局去重技术，都是在同一个理论框架下运作的，只是关注点和实现方式不同。这也解释了为什么在某些情况下，全局方法可以实现比局部方法更高的压缩率 —— 它们能够捕捉和利用更大范围内的信息冗余。\n\n如果您想进一步探讨某个具体方法如何与香农极限相关，或者讨论在特定场景下如何最佳地应用这些概念，我很乐意继续深入分析。\n```\n---\n#### Q4: What are the widely accepted definitions and relevant literature for traditional compression methods and chunking methods?\n```\n有比较公认的，对传统方法和chunking方法的起名，定义或是相关文献吗\n```\n#### A4:\n```\n确实有一些比较公认的术语和相关文献来描述这两种方法。让我为您总结一下：\n\n1. 传统方法\n\n通常被称为：\n- 数据压缩 (Data Compression)\n- 通用压缩 (General-purpose Compression)\n- 流压缩 (Stream Compression)\n\n主要算法和技术：\n- LZ77/LZ78 系列\n- Huffman 编码\n- 算术编码\n- 字典编码\n\n重要文献：\n- Ziv, J., & Lempel, A. (1977). A universal algorithm for sequential data compression. IEEE Transactions on Information Theory, 23(3), 337-343.\n- Huffman, D. A. (1952). A Method for the Construction of Minimum-Redundancy Codes. Proceedings of the IRE, 40(9), 1098-1101.\n\n2. Chunking 方法\n\n通常被称为：\n- 数据去重 (Data Deduplication)\n- 内容定义分块 (Content-Defined Chunking)\n- 重复数据删除 (Redundancy Elimination)\n\n主要算法和技术：\n- 固定大小分块 (Fixed-size Chunking)\n- 内容定义分块 (Content-Defined Chunking)\n- 滚动哈希 (Rolling Hash)\n- Rabin fingerprint\n\n重要文献：\n- Muthitacharoen, A., Chen, B., & Mazieres, D. (2001). A low-bandwidth network file system. ACM SIGOPS Operating Systems Review, 35(5), 174-187.\n- Quinlan, S., & Dorward, S. (2002). Venti: A New Approach to Archival Storage. In FAST (Vol. 2, pp. 89-101).\n\n3. 比较和综合\n\n一些文献对这两种方法进行了比较和综合：\n\n- Meister, D., & Brinkmann, A. (2009). Multi-level comparison of data deduplication in a backup scenario. In Proceedings of SYSTOR 2009: The Israeli Experimental Systems Conference (pp. 1-12).\n\n- Paulo, J., & Pereira, J. (2014). A survey and classification of storage deduplication systems. ACM Computing Surveys (CSUR), 47(1), 1-30.\n\n4. 新兴领域\n\n近年来，一些新的研究方向结合了这两种方法的特点：\n\n- 压缩去重 (Compression-aware Deduplication)\n- 学习型压缩 (Learned Compression)\n\n相关文献：\n- Xia, W., Jiang, H., Feng, D., & Hua, Y. (2016). Similarity and locality based indexing for high performance data deduplication. IEEE Transactions on Computers, 65(4), 1162-1176.\n\n- Kraska, T., Beutel, A., Chi, E. H., Dean, J., & Polyzotis, N. (2018). The case for learned index structures. In Proceedings of the 2018 International Conference on Management of Data (pp. 489-504).\n\n这些术语和文献提供了一个良好的起点，可以深入了解这两种方法的理论基础、实际应用和最新发展。传统压缩方法起源较早，有大量经典文献；而chunking和去重技术则相对较新，文献主要集中在过去二十年。\n\n如果您对某个特定领域或技术感兴趣，我可以提供更具体的文献建议。\n```\n\n---\n#### Q5: In specific dataset scenarios, does the chunking method break Shannon's compression limit?\n```\n我举个例子，数据集为64TiB，我chunking为每个块8MiB，块内字节非常随机，但块和块之前完全相同。在这种情况下传统无损压缩是遵循香农压缩极限的，但chunking类方法完全可以去重至只剩8MiB+许多recipe。这是否是突破了香农极限呢\n```\n#### A5:\n```\n您提出了一个非常有趣且富有洞察力的例子。这个例子很好地说明了传统压缩方法和基于chunking的去重方法在特定情况下的巨大差异。让我们深入分析这个情况：\n\n1. 传统无损压缩的表现\n\n在这种情况下，传统的无损压缩（如LZ77+Huffman）确实会受到香农压缩极限的限制：\n\n- 由于每个8MiB块内的字节是非常随机的，传统压缩算法可能无法有效压缩单个块。\n- 传统算法通常使用有限的滑动窗口（如32KB），无法捕捉到不同块之间的相似性。\n\n因此，传统方法可能只能实现很小的压缩率，接近于随机数据的香农熵极限。\n\n2. Chunking方法的表现\n\n使用chunking方法，情况就完全不同了：\n\n- 每个8MiB的块都会被识别为完全相同的。\n- 理论上，可以将64TiB的数据压缩到只有一个8MiB的块加上指向这个块的引用（recipe）。\n\n3. 是否突破了香农极限？\n\n从表面上看，chunking方法似乎\"突破\"了香农极限。但实际上，这并非突破，而是对信息源的不同理解和建模：\n\na) 信息源的重新定义：\n   - 传统方法将每个字节或小块看作独立的信息单元。\n   - Chunking方法将整个8MiB块视为一个信息单元。\n\nb) 条件熵的应用：\n   - 在chunking的视角下，给定第一个8MiB块，后续所有块的条件熵为零。\n   - 这符合香农的信息论原理，只是应用在了更大的尺度上。\n\nc) 元数据（Recipe）的角色：\n   - Recipe 本身也是数据，需要被计入总的数据量。\n   - Recipe 的大小也受到信息论限制，但相对于原始数据可能很小。\n\n4. 正确理解香农极限\n\n香农极限并没有被突破，而是被在更大的尺度上正确应用了：\n\n- 如果我们将整个64TiB数据视为一个整体，其实际熵非常低（因为只有8MiB的唯一信息）。\n- Chunking方法成功捕捉到了这种大尺度的低熵特性。\n\n5. 关键洞察\n\n这个例子揭示了几个重要观点：\n\na) 尺度的重要性：信息论原理可以在不同尺度上应用，选择合适的尺度至关重要。\n\nb) 模型的适应性：有效的压缩需要选择能够最好地捕捉数据实际特性的模型。\n\nc) 全局vs局部优化：有时全局视角可以发现局部方法无法捕捉的模式。\n\nd) 压缩的本质：真正高效的压缩是找到数据的最简洁表示，而不仅仅是局部的模式匹配。\n\n结论：\nchunking方法在这个例子中的惊人效果并不是突破了香农极限，而是更好地应用了信息论原理。它成功地在更大的尺度上捕捉到了数据的真实熵，这是传统方法因其局限性而无法做到的。\n\n这个例子完美地展示了为什么在某些场景下（如备份系统）chunking和去重技术能够实现如此高的压缩率。它也说明了为什么在设计压缩系统时，理解数据的实际结构和选择合适的压缩策略如此重要。\n```\n\n---\n","source":"_posts/24-8-23-chat-note.md","raw":"---\ntitle: chat-note:Data Compression & Data Deduplication\ndate: 20204-08-23 23:39:40\ntags:  \n  - Compression\n  - Storage system\ncategories:\n  - Compression algorithms\n  - chat note\n---\n#### Q1: Why is there such a significant difference between Huffman-type compression and post-chunking compression? Are they considered separate fields? What are their connections and differences?\n```\n我看信息论及其衍生出来的压缩方法都强调distance，例如窗口大小为32K时，他最多用distance为32576的字符串来去重。去重后再进行huffman编码来减少存储开销。  \n而在备份系统中因为chunking的存在，没有distance这个限制，完全可以与几百GiB之前的数据块进行压缩，但相应的chunking后的压缩算法需要recipe来记录源数据（用来解压）。  \n那么请问，为什么huffman编码类压缩和chunking后压缩区别如此大呢，这是否算是两个领域，有什么联系与区别\n```\n#### A1:\n```\n您提出了一个非常深刻的问题，这涉及到传统压缩算法和现代备份系统中数据去重技术的本质区别。让我们逐步分析这两种方法的特点、区别和联系：\n\n1. 传统压缩算法（如DEFLATE，使用在gzip中）\n\n特点：\n- 使用滑动窗口（通常为32KB）\n- 局部去重（LZ77算法）\n- Huffman编码减少冗余\n\n优势：\n- 单遍处理，内存需求小\n- 压缩和解压速度快\n- 不需要额外的元数据（除了很小的头部信息）\n\n限制：\n- 只能利用局部的重复性（32KB窗口内）\n- 压缩率受限于窗口大小\n\n2. 基于Chunking的备份系统压缩\n\n特点：\n- 全局去重\n- 可以引用任何之前见过的数据块\n- 需要额外的recipe来记录数据引用\n\n优势：\n- 可以利用全局的数据重复性\n- 对于有大量重复数据的场景（如备份），压缩率极高\n- 可以实现增量备份和快速恢复\n\n限制：\n- 需要维护大量元数据（recipe）\n- 通常需要更多的内存和存储空间来管理元数据\n- 压缩和解压可能更慢，尤其是随机访问时\n\n区别和联系：\n\n1. 范围差异：\n   传统压缩关注局部优化，而chunking关注全局优化。\n\n2. 使用场景：\n   传统压缩适用于单个文件或流，chunking更适合大规模存储系统。\n\n3. 元数据开销：\n   传统压缩几乎没有额外元数据，chunking需要大量元数据。\n\n4. 可扩展性：\n   chunking在数据量增加时可以保持高效，而传统压缩效率可能下降。\n\n5. 计算复杂度：\n   传统压缩通常计算复杂度较低，chunking可能需要更复杂的处理。\n\n6. 理论基础：\n   两者都基于信息论，但应用方式不同。传统压缩更直接应用熵编码，chunking更关注冗余消除。\n\n联系：\n\n1. 两种方法都试图利用数据的冗余性。\n2. 在某些系统中，这两种方法可以结合使用：先进行全局去重，然后对unique chunks应用传统压缩。\n3. 都受益于信息论的理论指导，如熵编码和冗余消除。\n\n为什么区别如此大：\n\n1. 设计目标不同：传统压缩针对单个文件优化，chunking针对大规模存储系统优化。\n2. 技术发展：chunking利用了现代系统更大的内存和存储能力。\n3. 应用场景：备份系统面临的数据特性（大量重复）与单个文件压缩不同。\n\n这两种方法确实可以视为压缩领域的两个不同分支，但它们有共同的理论基础，并且在现代系统中常常结合使用。选择哪种方法或如何结合，取决于具体的应用场景、系统资源和性能需求。\n\n如果您想深入了解这两种方法的某个具体方面，或者探讨它们在特定场景下的应用，我可以提供更详细的分析。\n```\n#### Q2: What are the primary application scenarios for chunking methods and traditional compression methods respectively?\n```\n所以只有备份系统场景下，才会需要chunking吗，压缩单个文件更倾向于使用LZ77+huffman这种传统方法?\n```\n#### A2\n```您的观察非常准确，但实际情况略微复杂一些。让我们深入探讨一下：\n\n1. 备份系统和Chunking\n\n确实，备份系统是Chunking技术最广泛和最有效的应用场景之一。原因包括：\n- 大量重复数据\n- 需要增量备份\n- 快速恢复的需求\n\n2. 单个文件压缩\n\n对于单个文件压缩，传统的LZ77+Huffman（如DEFLATE算法）确实是最常用的方法。原因包括：\n- 速度快\n- 内存需求低\n- 压缩率适中\n- 广泛兼容性\n\n3. Chunking在其他场景的应用\n\n然而，Chunking并不仅限于备份系统。它在其他场景也有应用：\n\na) 大型文件存储系统：\n   - 例如：Dropbox, Google Drive 等云存储服务\n   - 利用跨用户的数据重复性\n\nb) 内容分发网络（CDN）：\n   - 利用Chunking实现高效的内容更新和传输\n\nc) 版本控制系统：\n   - 如Git，使用类似Chunking的方法来高效存储文件的不同版本\n\nd) 大数据处理：\n   - 在某些大数据处理框架中，Chunking用于数据分割和去重\n\ne) 虚拟机镜像管理：\n   - 利用Chunking来高效存储和传输VM镜像\n\n4. 单文件压缩的新发展\n\n即使对于单文件压缩，也有一些新的发展借鉴了Chunking的思想：\n\na) LZMA（用在7z）：\n   - 使用更大的字典大小，接近全局去重的效果\n\nb) Zstandard：\n   - 提供大字典支持，可以利用更广范围的重复性\n\nc) 基于机器学习的压缩：\n   - 如Google的Gipfeli，尝试在单文件中识别和利用更广泛的模式\n\n5. 选择压缩方法的考虑因素\n\n选择使用传统方法还是Chunking（或其变体）取决于多个因素：\n\n- 数据规模\n- 重复模式（局部vs全局）\n- 压缩/解压速度要求\n- 随机访问需求\n- 存储和计算资源限制\n- 兼容性需求\n\n6. 混合方法\n\n在一些高级系统中，会结合使用这两种方法：\n- 首先使用Chunking进行全局去重\n- 然后对unique chunks使用传统压缩方法进一步压缩\n\n结论：\n虽然单文件压缩确实更倾向于使用传统方法，但Chunking的思想已经渗透到了更广泛的应用中。现代压缩技术正在不断融合这两种方法的优点，以适应不同的应用场景和数据特性。\n\n选择合适的方法需要深入理解数据特性和应用需求。在某些情况下，混合使用或选择专门设计的算法可能会带来更好的性能。\n\n如果您对某个特定场景或应用有更具体的问题，我很乐意提供更详细的分析和建议。\n```\n---\n#### Q3: Does Shannon's compression limit only apply to traditional local compression and Huffman coding?\n```\n我可以认为香农压缩极限只作用于传统的localcompression+huffman吗\n```\n#### A3:\n```\n这个问题触及了信息论的核心概念和其在不同压缩方法中的应用。让我们深入探讨一下：\n\n1. 香农压缩极限的普适性\n\n首先，需要明确的是，香农压缩极限（或香农熵）是一个普适的概念，适用于所有形式的无损数据压缩，不仅限于传统的局部压缩+Huffman编码。香农熵定义了在给定概率分布下，编码信息所需的理论最小平均比特数。\n\n2. 传统局部压缩+Huffman编码\n\n传统方法（如LZ77+Huffman）确实直接使用了香农压缩极限的概念：\n- LZ77利用局部重复性减少冗余\n- Huffman编码试图接近给定概率分布的熵\n\n这些方法在局部范围内（如32KB窗口）尝试接近香农极限。\n\n3. Chunking和全局去重\n\nChunking和全局去重虽然看起来与传统方法很不同，但它们同样受香农压缩极限的约束：\n\n- 理论基础：这些方法本质上是在更大的范围内寻找和消除冗余，这与熵的概念是一致的。\n\n- 全局优化：通过在更大范围内去重，这些方法实际上在尝试接近更大数据集的真实熵。\n\n- Recipe的作用：Recipe（或元数据）本质上是一种编码，其效率同样受熵的限制。\n\n4. 香农极限在不同尺度上的应用\n\n- 局部尺度：传统压缩在小范围内优化\n- 全局尺度：Chunking在更大范围内优化\n- 两者都在各自的尺度上试图接近香农极限\n\n5. 理解的关键点\n\n- 信息源模型：香农极限假设了一个特定的信息源模型。不同的压缩方法可能隐含地假设了不同的模型。\n\n- 计算复杂性：香农极限不考虑计算复杂性，而实际方法必须在效率和压缩率之间权衡。\n\n- 上下文和依赖：更复杂的方法（如Chunking）可能能够捕捉更多的上下文和长程依赖，从而在理论上更接近真实的熵。\n\n6. 结论\n\n因此，我们不能说香农压缩极限只作用于传统的局部压缩+Huffman方法。实际上：\n\n- 香农压缩极限适用于所有无损压缩方法。\n- 不同的方法在不同的尺度和假设下尝试接近这个极限。\n- Chunking和全局去重可以看作是在更大范围内应用熵编码原理的尝试。\n- 所有这些方法都受到信息论原理的指导，只是应用方式和范围不同。\n\n理解这一点很重要，因为它帮助我们认识到，无论是传统方法还是现代的全局去重技术，都是在同一个理论框架下运作的，只是关注点和实现方式不同。这也解释了为什么在某些情况下，全局方法可以实现比局部方法更高的压缩率 —— 它们能够捕捉和利用更大范围内的信息冗余。\n\n如果您想进一步探讨某个具体方法如何与香农极限相关，或者讨论在特定场景下如何最佳地应用这些概念，我很乐意继续深入分析。\n```\n---\n#### Q4: What are the widely accepted definitions and relevant literature for traditional compression methods and chunking methods?\n```\n有比较公认的，对传统方法和chunking方法的起名，定义或是相关文献吗\n```\n#### A4:\n```\n确实有一些比较公认的术语和相关文献来描述这两种方法。让我为您总结一下：\n\n1. 传统方法\n\n通常被称为：\n- 数据压缩 (Data Compression)\n- 通用压缩 (General-purpose Compression)\n- 流压缩 (Stream Compression)\n\n主要算法和技术：\n- LZ77/LZ78 系列\n- Huffman 编码\n- 算术编码\n- 字典编码\n\n重要文献：\n- Ziv, J., & Lempel, A. (1977). A universal algorithm for sequential data compression. IEEE Transactions on Information Theory, 23(3), 337-343.\n- Huffman, D. A. (1952). A Method for the Construction of Minimum-Redundancy Codes. Proceedings of the IRE, 40(9), 1098-1101.\n\n2. Chunking 方法\n\n通常被称为：\n- 数据去重 (Data Deduplication)\n- 内容定义分块 (Content-Defined Chunking)\n- 重复数据删除 (Redundancy Elimination)\n\n主要算法和技术：\n- 固定大小分块 (Fixed-size Chunking)\n- 内容定义分块 (Content-Defined Chunking)\n- 滚动哈希 (Rolling Hash)\n- Rabin fingerprint\n\n重要文献：\n- Muthitacharoen, A., Chen, B., & Mazieres, D. (2001). A low-bandwidth network file system. ACM SIGOPS Operating Systems Review, 35(5), 174-187.\n- Quinlan, S., & Dorward, S. (2002). Venti: A New Approach to Archival Storage. In FAST (Vol. 2, pp. 89-101).\n\n3. 比较和综合\n\n一些文献对这两种方法进行了比较和综合：\n\n- Meister, D., & Brinkmann, A. (2009). Multi-level comparison of data deduplication in a backup scenario. In Proceedings of SYSTOR 2009: The Israeli Experimental Systems Conference (pp. 1-12).\n\n- Paulo, J., & Pereira, J. (2014). A survey and classification of storage deduplication systems. ACM Computing Surveys (CSUR), 47(1), 1-30.\n\n4. 新兴领域\n\n近年来，一些新的研究方向结合了这两种方法的特点：\n\n- 压缩去重 (Compression-aware Deduplication)\n- 学习型压缩 (Learned Compression)\n\n相关文献：\n- Xia, W., Jiang, H., Feng, D., & Hua, Y. (2016). Similarity and locality based indexing for high performance data deduplication. IEEE Transactions on Computers, 65(4), 1162-1176.\n\n- Kraska, T., Beutel, A., Chi, E. H., Dean, J., & Polyzotis, N. (2018). The case for learned index structures. In Proceedings of the 2018 International Conference on Management of Data (pp. 489-504).\n\n这些术语和文献提供了一个良好的起点，可以深入了解这两种方法的理论基础、实际应用和最新发展。传统压缩方法起源较早，有大量经典文献；而chunking和去重技术则相对较新，文献主要集中在过去二十年。\n\n如果您对某个特定领域或技术感兴趣，我可以提供更具体的文献建议。\n```\n\n---\n#### Q5: In specific dataset scenarios, does the chunking method break Shannon's compression limit?\n```\n我举个例子，数据集为64TiB，我chunking为每个块8MiB，块内字节非常随机，但块和块之前完全相同。在这种情况下传统无损压缩是遵循香农压缩极限的，但chunking类方法完全可以去重至只剩8MiB+许多recipe。这是否是突破了香农极限呢\n```\n#### A5:\n```\n您提出了一个非常有趣且富有洞察力的例子。这个例子很好地说明了传统压缩方法和基于chunking的去重方法在特定情况下的巨大差异。让我们深入分析这个情况：\n\n1. 传统无损压缩的表现\n\n在这种情况下，传统的无损压缩（如LZ77+Huffman）确实会受到香农压缩极限的限制：\n\n- 由于每个8MiB块内的字节是非常随机的，传统压缩算法可能无法有效压缩单个块。\n- 传统算法通常使用有限的滑动窗口（如32KB），无法捕捉到不同块之间的相似性。\n\n因此，传统方法可能只能实现很小的压缩率，接近于随机数据的香农熵极限。\n\n2. Chunking方法的表现\n\n使用chunking方法，情况就完全不同了：\n\n- 每个8MiB的块都会被识别为完全相同的。\n- 理论上，可以将64TiB的数据压缩到只有一个8MiB的块加上指向这个块的引用（recipe）。\n\n3. 是否突破了香农极限？\n\n从表面上看，chunking方法似乎\"突破\"了香农极限。但实际上，这并非突破，而是对信息源的不同理解和建模：\n\na) 信息源的重新定义：\n   - 传统方法将每个字节或小块看作独立的信息单元。\n   - Chunking方法将整个8MiB块视为一个信息单元。\n\nb) 条件熵的应用：\n   - 在chunking的视角下，给定第一个8MiB块，后续所有块的条件熵为零。\n   - 这符合香农的信息论原理，只是应用在了更大的尺度上。\n\nc) 元数据（Recipe）的角色：\n   - Recipe 本身也是数据，需要被计入总的数据量。\n   - Recipe 的大小也受到信息论限制，但相对于原始数据可能很小。\n\n4. 正确理解香农极限\n\n香农极限并没有被突破，而是被在更大的尺度上正确应用了：\n\n- 如果我们将整个64TiB数据视为一个整体，其实际熵非常低（因为只有8MiB的唯一信息）。\n- Chunking方法成功捕捉到了这种大尺度的低熵特性。\n\n5. 关键洞察\n\n这个例子揭示了几个重要观点：\n\na) 尺度的重要性：信息论原理可以在不同尺度上应用，选择合适的尺度至关重要。\n\nb) 模型的适应性：有效的压缩需要选择能够最好地捕捉数据实际特性的模型。\n\nc) 全局vs局部优化：有时全局视角可以发现局部方法无法捕捉的模式。\n\nd) 压缩的本质：真正高效的压缩是找到数据的最简洁表示，而不仅仅是局部的模式匹配。\n\n结论：\nchunking方法在这个例子中的惊人效果并不是突破了香农极限，而是更好地应用了信息论原理。它成功地在更大的尺度上捕捉到了数据的真实熵，这是传统方法因其局限性而无法做到的。\n\n这个例子完美地展示了为什么在某些场景下（如备份系统）chunking和去重技术能够实现如此高的压缩率。它也说明了为什么在设计压缩系统时，理解数据的实际结构和选择合适的压缩策略如此重要。\n```\n\n---\n","slug":"24-8-23-chat-note","published":1,"updated":"2024-08-23T15:45:37.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm06vvh0t000024unc7h55g6h","content":"<h4 id=\"q1-why-is-there-such-a-significant-difference-between-huffman-type-compression-and-post-chunking-compression-are-they-considered-separate-fields-what-are-their-connections-and-differences\"><a class=\"anchor\" href=\"#q1-why-is-there-such-a-significant-difference-between-huffman-type-compression-and-post-chunking-compression-are-they-considered-separate-fields-what-are-their-connections-and-differences\">#</a> Q1: Why is there such a significant difference between Huffman-type compression and post-chunking compression? Are they considered separate fields? What are their connections and differences?</h4>\n<pre><code>我看信息论及其衍生出来的压缩方法都强调distance，例如窗口大小为32K时，他最多用distance为32576的字符串来去重。去重后再进行huffman编码来减少存储开销。  \n而在备份系统中因为chunking的存在，没有distance这个限制，完全可以与几百GiB之前的数据块进行压缩，但相应的chunking后的压缩算法需要recipe来记录源数据（用来解压）。  \n那么请问，为什么huffman编码类压缩和chunking后压缩区别如此大呢，这是否算是两个领域，有什么联系与区别\n</code></pre>\n<h4 id=\"a1\"><a class=\"anchor\" href=\"#a1\">#</a> A1:</h4>\n<pre><code>您提出了一个非常深刻的问题，这涉及到传统压缩算法和现代备份系统中数据去重技术的本质区别。让我们逐步分析这两种方法的特点、区别和联系：\n\n1. 传统压缩算法（如DEFLATE，使用在gzip中）\n\n特点：\n- 使用滑动窗口（通常为32KB）\n- 局部去重（LZ77算法）\n- Huffman编码减少冗余\n\n优势：\n- 单遍处理，内存需求小\n- 压缩和解压速度快\n- 不需要额外的元数据（除了很小的头部信息）\n\n限制：\n- 只能利用局部的重复性（32KB窗口内）\n- 压缩率受限于窗口大小\n\n2. 基于Chunking的备份系统压缩\n\n特点：\n- 全局去重\n- 可以引用任何之前见过的数据块\n- 需要额外的recipe来记录数据引用\n\n优势：\n- 可以利用全局的数据重复性\n- 对于有大量重复数据的场景（如备份），压缩率极高\n- 可以实现增量备份和快速恢复\n\n限制：\n- 需要维护大量元数据（recipe）\n- 通常需要更多的内存和存储空间来管理元数据\n- 压缩和解压可能更慢，尤其是随机访问时\n\n区别和联系：\n\n1. 范围差异：\n   传统压缩关注局部优化，而chunking关注全局优化。\n\n2. 使用场景：\n   传统压缩适用于单个文件或流，chunking更适合大规模存储系统。\n\n3. 元数据开销：\n   传统压缩几乎没有额外元数据，chunking需要大量元数据。\n\n4. 可扩展性：\n   chunking在数据量增加时可以保持高效，而传统压缩效率可能下降。\n\n5. 计算复杂度：\n   传统压缩通常计算复杂度较低，chunking可能需要更复杂的处理。\n\n6. 理论基础：\n   两者都基于信息论，但应用方式不同。传统压缩更直接应用熵编码，chunking更关注冗余消除。\n\n联系：\n\n1. 两种方法都试图利用数据的冗余性。\n2. 在某些系统中，这两种方法可以结合使用：先进行全局去重，然后对unique chunks应用传统压缩。\n3. 都受益于信息论的理论指导，如熵编码和冗余消除。\n\n为什么区别如此大：\n\n1. 设计目标不同：传统压缩针对单个文件优化，chunking针对大规模存储系统优化。\n2. 技术发展：chunking利用了现代系统更大的内存和存储能力。\n3. 应用场景：备份系统面临的数据特性（大量重复）与单个文件压缩不同。\n\n这两种方法确实可以视为压缩领域的两个不同分支，但它们有共同的理论基础，并且在现代系统中常常结合使用。选择哪种方法或如何结合，取决于具体的应用场景、系统资源和性能需求。\n\n如果您想深入了解这两种方法的某个具体方面，或者探讨它们在特定场景下的应用，我可以提供更详细的分析。\n</code></pre>\n<h4 id=\"q2-what-are-the-primary-application-scenarios-for-chunking-methods-and-traditional-compression-methods-respectively\"><a class=\"anchor\" href=\"#q2-what-are-the-primary-application-scenarios-for-chunking-methods-and-traditional-compression-methods-respectively\">#</a> Q2: What are the primary application scenarios for chunking methods and traditional compression methods respectively?</h4>\n<pre><code>所以只有备份系统场景下，才会需要chunking吗，压缩单个文件更倾向于使用LZ77+huffman这种传统方法?\n</code></pre>\n<h4 id=\"a2\"><a class=\"anchor\" href=\"#a2\">#</a> A2</h4>\n<pre><code class=\"language-您的观察非常准确，但实际情况略微复杂一些。让我们深入探讨一下：\">\n1. 备份系统和Chunking\n\n确实，备份系统是Chunking技术最广泛和最有效的应用场景之一。原因包括：\n- 大量重复数据\n- 需要增量备份\n- 快速恢复的需求\n\n2. 单个文件压缩\n\n对于单个文件压缩，传统的LZ77+Huffman（如DEFLATE算法）确实是最常用的方法。原因包括：\n- 速度快\n- 内存需求低\n- 压缩率适中\n- 广泛兼容性\n\n3. Chunking在其他场景的应用\n\n然而，Chunking并不仅限于备份系统。它在其他场景也有应用：\n\na) 大型文件存储系统：\n   - 例如：Dropbox, Google Drive 等云存储服务\n   - 利用跨用户的数据重复性\n\nb) 内容分发网络（CDN）：\n   - 利用Chunking实现高效的内容更新和传输\n\nc) 版本控制系统：\n   - 如Git，使用类似Chunking的方法来高效存储文件的不同版本\n\nd) 大数据处理：\n   - 在某些大数据处理框架中，Chunking用于数据分割和去重\n\ne) 虚拟机镜像管理：\n   - 利用Chunking来高效存储和传输VM镜像\n\n4. 单文件压缩的新发展\n\n即使对于单文件压缩，也有一些新的发展借鉴了Chunking的思想：\n\na) LZMA（用在7z）：\n   - 使用更大的字典大小，接近全局去重的效果\n\nb) Zstandard：\n   - 提供大字典支持，可以利用更广范围的重复性\n\nc) 基于机器学习的压缩：\n   - 如Google的Gipfeli，尝试在单文件中识别和利用更广泛的模式\n\n5. 选择压缩方法的考虑因素\n\n选择使用传统方法还是Chunking（或其变体）取决于多个因素：\n\n- 数据规模\n- 重复模式（局部vs全局）\n- 压缩/解压速度要求\n- 随机访问需求\n- 存储和计算资源限制\n- 兼容性需求\n\n6. 混合方法\n\n在一些高级系统中，会结合使用这两种方法：\n- 首先使用Chunking进行全局去重\n- 然后对unique chunks使用传统压缩方法进一步压缩\n\n结论：\n虽然单文件压缩确实更倾向于使用传统方法，但Chunking的思想已经渗透到了更广泛的应用中。现代压缩技术正在不断融合这两种方法的优点，以适应不同的应用场景和数据特性。\n\n选择合适的方法需要深入理解数据特性和应用需求。在某些情况下，混合使用或选择专门设计的算法可能会带来更好的性能。\n\n如果您对某个特定场景或应用有更具体的问题，我很乐意提供更详细的分析和建议。\n</code></pre>\n<hr />\n<h4 id=\"q3-does-shannons-compression-limit-only-apply-to-traditional-local-compression-and-huffman-coding\"><a class=\"anchor\" href=\"#q3-does-shannons-compression-limit-only-apply-to-traditional-local-compression-and-huffman-coding\">#</a> Q3: Does Shannon's compression limit only apply to traditional local compression and Huffman coding?</h4>\n<pre><code>我可以认为香农压缩极限只作用于传统的localcompression+huffman吗\n</code></pre>\n<h4 id=\"a3\"><a class=\"anchor\" href=\"#a3\">#</a> A3:</h4>\n<pre><code>这个问题触及了信息论的核心概念和其在不同压缩方法中的应用。让我们深入探讨一下：\n\n1. 香农压缩极限的普适性\n\n首先，需要明确的是，香农压缩极限（或香农熵）是一个普适的概念，适用于所有形式的无损数据压缩，不仅限于传统的局部压缩+Huffman编码。香农熵定义了在给定概率分布下，编码信息所需的理论最小平均比特数。\n\n2. 传统局部压缩+Huffman编码\n\n传统方法（如LZ77+Huffman）确实直接使用了香农压缩极限的概念：\n- LZ77利用局部重复性减少冗余\n- Huffman编码试图接近给定概率分布的熵\n\n这些方法在局部范围内（如32KB窗口）尝试接近香农极限。\n\n3. Chunking和全局去重\n\nChunking和全局去重虽然看起来与传统方法很不同，但它们同样受香农压缩极限的约束：\n\n- 理论基础：这些方法本质上是在更大的范围内寻找和消除冗余，这与熵的概念是一致的。\n\n- 全局优化：通过在更大范围内去重，这些方法实际上在尝试接近更大数据集的真实熵。\n\n- Recipe的作用：Recipe（或元数据）本质上是一种编码，其效率同样受熵的限制。\n\n4. 香农极限在不同尺度上的应用\n\n- 局部尺度：传统压缩在小范围内优化\n- 全局尺度：Chunking在更大范围内优化\n- 两者都在各自的尺度上试图接近香农极限\n\n5. 理解的关键点\n\n- 信息源模型：香农极限假设了一个特定的信息源模型。不同的压缩方法可能隐含地假设了不同的模型。\n\n- 计算复杂性：香农极限不考虑计算复杂性，而实际方法必须在效率和压缩率之间权衡。\n\n- 上下文和依赖：更复杂的方法（如Chunking）可能能够捕捉更多的上下文和长程依赖，从而在理论上更接近真实的熵。\n\n6. 结论\n\n因此，我们不能说香农压缩极限只作用于传统的局部压缩+Huffman方法。实际上：\n\n- 香农压缩极限适用于所有无损压缩方法。\n- 不同的方法在不同的尺度和假设下尝试接近这个极限。\n- Chunking和全局去重可以看作是在更大范围内应用熵编码原理的尝试。\n- 所有这些方法都受到信息论原理的指导，只是应用方式和范围不同。\n\n理解这一点很重要，因为它帮助我们认识到，无论是传统方法还是现代的全局去重技术，都是在同一个理论框架下运作的，只是关注点和实现方式不同。这也解释了为什么在某些情况下，全局方法可以实现比局部方法更高的压缩率 —— 它们能够捕捉和利用更大范围内的信息冗余。\n\n如果您想进一步探讨某个具体方法如何与香农极限相关，或者讨论在特定场景下如何最佳地应用这些概念，我很乐意继续深入分析。\n</code></pre>\n<hr />\n<h4 id=\"q4-what-are-the-widely-accepted-definitions-and-relevant-literature-for-traditional-compression-methods-and-chunking-methods\"><a class=\"anchor\" href=\"#q4-what-are-the-widely-accepted-definitions-and-relevant-literature-for-traditional-compression-methods-and-chunking-methods\">#</a> Q4: What are the widely accepted definitions and relevant literature for traditional compression methods and chunking methods?</h4>\n<pre><code>有比较公认的，对传统方法和chunking方法的起名，定义或是相关文献吗\n</code></pre>\n<h4 id=\"a4\"><a class=\"anchor\" href=\"#a4\">#</a> A4:</h4>\n<pre><code>确实有一些比较公认的术语和相关文献来描述这两种方法。让我为您总结一下：\n\n1. 传统方法\n\n通常被称为：\n- 数据压缩 (Data Compression)\n- 通用压缩 (General-purpose Compression)\n- 流压缩 (Stream Compression)\n\n主要算法和技术：\n- LZ77/LZ78 系列\n- Huffman 编码\n- 算术编码\n- 字典编码\n\n重要文献：\n- Ziv, J., &amp; Lempel, A. (1977). A universal algorithm for sequential data compression. IEEE Transactions on Information Theory, 23(3), 337-343.\n- Huffman, D. A. (1952). A Method for the Construction of Minimum-Redundancy Codes. Proceedings of the IRE, 40(9), 1098-1101.\n\n2. Chunking 方法\n\n通常被称为：\n- 数据去重 (Data Deduplication)\n- 内容定义分块 (Content-Defined Chunking)\n- 重复数据删除 (Redundancy Elimination)\n\n主要算法和技术：\n- 固定大小分块 (Fixed-size Chunking)\n- 内容定义分块 (Content-Defined Chunking)\n- 滚动哈希 (Rolling Hash)\n- Rabin fingerprint\n\n重要文献：\n- Muthitacharoen, A., Chen, B., &amp; Mazieres, D. (2001). A low-bandwidth network file system. ACM SIGOPS Operating Systems Review, 35(5), 174-187.\n- Quinlan, S., &amp; Dorward, S. (2002). Venti: A New Approach to Archival Storage. In FAST (Vol. 2, pp. 89-101).\n\n3. 比较和综合\n\n一些文献对这两种方法进行了比较和综合：\n\n- Meister, D., &amp; Brinkmann, A. (2009). Multi-level comparison of data deduplication in a backup scenario. In Proceedings of SYSTOR 2009: The Israeli Experimental Systems Conference (pp. 1-12).\n\n- Paulo, J., &amp; Pereira, J. (2014). A survey and classification of storage deduplication systems. ACM Computing Surveys (CSUR), 47(1), 1-30.\n\n4. 新兴领域\n\n近年来，一些新的研究方向结合了这两种方法的特点：\n\n- 压缩去重 (Compression-aware Deduplication)\n- 学习型压缩 (Learned Compression)\n\n相关文献：\n- Xia, W., Jiang, H., Feng, D., &amp; Hua, Y. (2016). Similarity and locality based indexing for high performance data deduplication. IEEE Transactions on Computers, 65(4), 1162-1176.\n\n- Kraska, T., Beutel, A., Chi, E. H., Dean, J., &amp; Polyzotis, N. (2018). The case for learned index structures. In Proceedings of the 2018 International Conference on Management of Data (pp. 489-504).\n\n这些术语和文献提供了一个良好的起点，可以深入了解这两种方法的理论基础、实际应用和最新发展。传统压缩方法起源较早，有大量经典文献；而chunking和去重技术则相对较新，文献主要集中在过去二十年。\n\n如果您对某个特定领域或技术感兴趣，我可以提供更具体的文献建议。\n</code></pre>\n<hr />\n<h4 id=\"q5-in-specific-dataset-scenarios-does-the-chunking-method-break-shannons-compression-limit\"><a class=\"anchor\" href=\"#q5-in-specific-dataset-scenarios-does-the-chunking-method-break-shannons-compression-limit\">#</a> Q5: In specific dataset scenarios, does the chunking method break Shannon's compression limit?</h4>\n<pre><code>我举个例子，数据集为64TiB，我chunking为每个块8MiB，块内字节非常随机，但块和块之前完全相同。在这种情况下传统无损压缩是遵循香农压缩极限的，但chunking类方法完全可以去重至只剩8MiB+许多recipe。这是否是突破了香农极限呢\n</code></pre>\n<h4 id=\"a5\"><a class=\"anchor\" href=\"#a5\">#</a> A5:</h4>\n<pre><code>您提出了一个非常有趣且富有洞察力的例子。这个例子很好地说明了传统压缩方法和基于chunking的去重方法在特定情况下的巨大差异。让我们深入分析这个情况：\n\n1. 传统无损压缩的表现\n\n在这种情况下，传统的无损压缩（如LZ77+Huffman）确实会受到香农压缩极限的限制：\n\n- 由于每个8MiB块内的字节是非常随机的，传统压缩算法可能无法有效压缩单个块。\n- 传统算法通常使用有限的滑动窗口（如32KB），无法捕捉到不同块之间的相似性。\n\n因此，传统方法可能只能实现很小的压缩率，接近于随机数据的香农熵极限。\n\n2. Chunking方法的表现\n\n使用chunking方法，情况就完全不同了：\n\n- 每个8MiB的块都会被识别为完全相同的。\n- 理论上，可以将64TiB的数据压缩到只有一个8MiB的块加上指向这个块的引用（recipe）。\n\n3. 是否突破了香农极限？\n\n从表面上看，chunking方法似乎&quot;突破&quot;了香农极限。但实际上，这并非突破，而是对信息源的不同理解和建模：\n\na) 信息源的重新定义：\n   - 传统方法将每个字节或小块看作独立的信息单元。\n   - Chunking方法将整个8MiB块视为一个信息单元。\n\nb) 条件熵的应用：\n   - 在chunking的视角下，给定第一个8MiB块，后续所有块的条件熵为零。\n   - 这符合香农的信息论原理，只是应用在了更大的尺度上。\n\nc) 元数据（Recipe）的角色：\n   - Recipe 本身也是数据，需要被计入总的数据量。\n   - Recipe 的大小也受到信息论限制，但相对于原始数据可能很小。\n\n4. 正确理解香农极限\n\n香农极限并没有被突破，而是被在更大的尺度上正确应用了：\n\n- 如果我们将整个64TiB数据视为一个整体，其实际熵非常低（因为只有8MiB的唯一信息）。\n- Chunking方法成功捕捉到了这种大尺度的低熵特性。\n\n5. 关键洞察\n\n这个例子揭示了几个重要观点：\n\na) 尺度的重要性：信息论原理可以在不同尺度上应用，选择合适的尺度至关重要。\n\nb) 模型的适应性：有效的压缩需要选择能够最好地捕捉数据实际特性的模型。\n\nc) 全局vs局部优化：有时全局视角可以发现局部方法无法捕捉的模式。\n\nd) 压缩的本质：真正高效的压缩是找到数据的最简洁表示，而不仅仅是局部的模式匹配。\n\n结论：\nchunking方法在这个例子中的惊人效果并不是突破了香农极限，而是更好地应用了信息论原理。它成功地在更大的尺度上捕捉到了数据的真实熵，这是传统方法因其局限性而无法做到的。\n\n这个例子完美地展示了为什么在某些场景下（如备份系统）chunking和去重技术能够实现如此高的压缩率。它也说明了为什么在设计压缩系统时，理解数据的实际结构和选择合适的压缩策略如此重要。\n</code></pre>\n<hr />\n","site":{"data":{}},"length":6790,"excerpt":"","more":"<h4 id=\"q1-why-is-there-such-a-significant-difference-between-huffman-type-compression-and-post-chunking-compression-are-they-considered-separate-fields-what-are-their-connections-and-differences\"><a class=\"anchor\" href=\"#q1-why-is-there-such-a-significant-difference-between-huffman-type-compression-and-post-chunking-compression-are-they-considered-separate-fields-what-are-their-connections-and-differences\">#</a> Q1: Why is there such a significant difference between Huffman-type compression and post-chunking compression? Are they considered separate fields? What are their connections and differences?</h4>\n<pre><code>我看信息论及其衍生出来的压缩方法都强调distance，例如窗口大小为32K时，他最多用distance为32576的字符串来去重。去重后再进行huffman编码来减少存储开销。  \n而在备份系统中因为chunking的存在，没有distance这个限制，完全可以与几百GiB之前的数据块进行压缩，但相应的chunking后的压缩算法需要recipe来记录源数据（用来解压）。  \n那么请问，为什么huffman编码类压缩和chunking后压缩区别如此大呢，这是否算是两个领域，有什么联系与区别\n</code></pre>\n<h4 id=\"a1\"><a class=\"anchor\" href=\"#a1\">#</a> A1:</h4>\n<pre><code>您提出了一个非常深刻的问题，这涉及到传统压缩算法和现代备份系统中数据去重技术的本质区别。让我们逐步分析这两种方法的特点、区别和联系：\n\n1. 传统压缩算法（如DEFLATE，使用在gzip中）\n\n特点：\n- 使用滑动窗口（通常为32KB）\n- 局部去重（LZ77算法）\n- Huffman编码减少冗余\n\n优势：\n- 单遍处理，内存需求小\n- 压缩和解压速度快\n- 不需要额外的元数据（除了很小的头部信息）\n\n限制：\n- 只能利用局部的重复性（32KB窗口内）\n- 压缩率受限于窗口大小\n\n2. 基于Chunking的备份系统压缩\n\n特点：\n- 全局去重\n- 可以引用任何之前见过的数据块\n- 需要额外的recipe来记录数据引用\n\n优势：\n- 可以利用全局的数据重复性\n- 对于有大量重复数据的场景（如备份），压缩率极高\n- 可以实现增量备份和快速恢复\n\n限制：\n- 需要维护大量元数据（recipe）\n- 通常需要更多的内存和存储空间来管理元数据\n- 压缩和解压可能更慢，尤其是随机访问时\n\n区别和联系：\n\n1. 范围差异：\n   传统压缩关注局部优化，而chunking关注全局优化。\n\n2. 使用场景：\n   传统压缩适用于单个文件或流，chunking更适合大规模存储系统。\n\n3. 元数据开销：\n   传统压缩几乎没有额外元数据，chunking需要大量元数据。\n\n4. 可扩展性：\n   chunking在数据量增加时可以保持高效，而传统压缩效率可能下降。\n\n5. 计算复杂度：\n   传统压缩通常计算复杂度较低，chunking可能需要更复杂的处理。\n\n6. 理论基础：\n   两者都基于信息论，但应用方式不同。传统压缩更直接应用熵编码，chunking更关注冗余消除。\n\n联系：\n\n1. 两种方法都试图利用数据的冗余性。\n2. 在某些系统中，这两种方法可以结合使用：先进行全局去重，然后对unique chunks应用传统压缩。\n3. 都受益于信息论的理论指导，如熵编码和冗余消除。\n\n为什么区别如此大：\n\n1. 设计目标不同：传统压缩针对单个文件优化，chunking针对大规模存储系统优化。\n2. 技术发展：chunking利用了现代系统更大的内存和存储能力。\n3. 应用场景：备份系统面临的数据特性（大量重复）与单个文件压缩不同。\n\n这两种方法确实可以视为压缩领域的两个不同分支，但它们有共同的理论基础，并且在现代系统中常常结合使用。选择哪种方法或如何结合，取决于具体的应用场景、系统资源和性能需求。\n\n如果您想深入了解这两种方法的某个具体方面，或者探讨它们在特定场景下的应用，我可以提供更详细的分析。\n</code></pre>\n<h4 id=\"q2-what-are-the-primary-application-scenarios-for-chunking-methods-and-traditional-compression-methods-respectively\"><a class=\"anchor\" href=\"#q2-what-are-the-primary-application-scenarios-for-chunking-methods-and-traditional-compression-methods-respectively\">#</a> Q2: What are the primary application scenarios for chunking methods and traditional compression methods respectively?</h4>\n<pre><code>所以只有备份系统场景下，才会需要chunking吗，压缩单个文件更倾向于使用LZ77+huffman这种传统方法?\n</code></pre>\n<h4 id=\"a2\"><a class=\"anchor\" href=\"#a2\">#</a> A2</h4>\n<pre><code class=\"language-您的观察非常准确，但实际情况略微复杂一些。让我们深入探讨一下：\">\n1. 备份系统和Chunking\n\n确实，备份系统是Chunking技术最广泛和最有效的应用场景之一。原因包括：\n- 大量重复数据\n- 需要增量备份\n- 快速恢复的需求\n\n2. 单个文件压缩\n\n对于单个文件压缩，传统的LZ77+Huffman（如DEFLATE算法）确实是最常用的方法。原因包括：\n- 速度快\n- 内存需求低\n- 压缩率适中\n- 广泛兼容性\n\n3. Chunking在其他场景的应用\n\n然而，Chunking并不仅限于备份系统。它在其他场景也有应用：\n\na) 大型文件存储系统：\n   - 例如：Dropbox, Google Drive 等云存储服务\n   - 利用跨用户的数据重复性\n\nb) 内容分发网络（CDN）：\n   - 利用Chunking实现高效的内容更新和传输\n\nc) 版本控制系统：\n   - 如Git，使用类似Chunking的方法来高效存储文件的不同版本\n\nd) 大数据处理：\n   - 在某些大数据处理框架中，Chunking用于数据分割和去重\n\ne) 虚拟机镜像管理：\n   - 利用Chunking来高效存储和传输VM镜像\n\n4. 单文件压缩的新发展\n\n即使对于单文件压缩，也有一些新的发展借鉴了Chunking的思想：\n\na) LZMA（用在7z）：\n   - 使用更大的字典大小，接近全局去重的效果\n\nb) Zstandard：\n   - 提供大字典支持，可以利用更广范围的重复性\n\nc) 基于机器学习的压缩：\n   - 如Google的Gipfeli，尝试在单文件中识别和利用更广泛的模式\n\n5. 选择压缩方法的考虑因素\n\n选择使用传统方法还是Chunking（或其变体）取决于多个因素：\n\n- 数据规模\n- 重复模式（局部vs全局）\n- 压缩/解压速度要求\n- 随机访问需求\n- 存储和计算资源限制\n- 兼容性需求\n\n6. 混合方法\n\n在一些高级系统中，会结合使用这两种方法：\n- 首先使用Chunking进行全局去重\n- 然后对unique chunks使用传统压缩方法进一步压缩\n\n结论：\n虽然单文件压缩确实更倾向于使用传统方法，但Chunking的思想已经渗透到了更广泛的应用中。现代压缩技术正在不断融合这两种方法的优点，以适应不同的应用场景和数据特性。\n\n选择合适的方法需要深入理解数据特性和应用需求。在某些情况下，混合使用或选择专门设计的算法可能会带来更好的性能。\n\n如果您对某个特定场景或应用有更具体的问题，我很乐意提供更详细的分析和建议。\n</code></pre>\n<hr />\n<h4 id=\"q3-does-shannons-compression-limit-only-apply-to-traditional-local-compression-and-huffman-coding\"><a class=\"anchor\" href=\"#q3-does-shannons-compression-limit-only-apply-to-traditional-local-compression-and-huffman-coding\">#</a> Q3: Does Shannon's compression limit only apply to traditional local compression and Huffman coding?</h4>\n<pre><code>我可以认为香农压缩极限只作用于传统的localcompression+huffman吗\n</code></pre>\n<h4 id=\"a3\"><a class=\"anchor\" href=\"#a3\">#</a> A3:</h4>\n<pre><code>这个问题触及了信息论的核心概念和其在不同压缩方法中的应用。让我们深入探讨一下：\n\n1. 香农压缩极限的普适性\n\n首先，需要明确的是，香农压缩极限（或香农熵）是一个普适的概念，适用于所有形式的无损数据压缩，不仅限于传统的局部压缩+Huffman编码。香农熵定义了在给定概率分布下，编码信息所需的理论最小平均比特数。\n\n2. 传统局部压缩+Huffman编码\n\n传统方法（如LZ77+Huffman）确实直接使用了香农压缩极限的概念：\n- LZ77利用局部重复性减少冗余\n- Huffman编码试图接近给定概率分布的熵\n\n这些方法在局部范围内（如32KB窗口）尝试接近香农极限。\n\n3. Chunking和全局去重\n\nChunking和全局去重虽然看起来与传统方法很不同，但它们同样受香农压缩极限的约束：\n\n- 理论基础：这些方法本质上是在更大的范围内寻找和消除冗余，这与熵的概念是一致的。\n\n- 全局优化：通过在更大范围内去重，这些方法实际上在尝试接近更大数据集的真实熵。\n\n- Recipe的作用：Recipe（或元数据）本质上是一种编码，其效率同样受熵的限制。\n\n4. 香农极限在不同尺度上的应用\n\n- 局部尺度：传统压缩在小范围内优化\n- 全局尺度：Chunking在更大范围内优化\n- 两者都在各自的尺度上试图接近香农极限\n\n5. 理解的关键点\n\n- 信息源模型：香农极限假设了一个特定的信息源模型。不同的压缩方法可能隐含地假设了不同的模型。\n\n- 计算复杂性：香农极限不考虑计算复杂性，而实际方法必须在效率和压缩率之间权衡。\n\n- 上下文和依赖：更复杂的方法（如Chunking）可能能够捕捉更多的上下文和长程依赖，从而在理论上更接近真实的熵。\n\n6. 结论\n\n因此，我们不能说香农压缩极限只作用于传统的局部压缩+Huffman方法。实际上：\n\n- 香农压缩极限适用于所有无损压缩方法。\n- 不同的方法在不同的尺度和假设下尝试接近这个极限。\n- Chunking和全局去重可以看作是在更大范围内应用熵编码原理的尝试。\n- 所有这些方法都受到信息论原理的指导，只是应用方式和范围不同。\n\n理解这一点很重要，因为它帮助我们认识到，无论是传统方法还是现代的全局去重技术，都是在同一个理论框架下运作的，只是关注点和实现方式不同。这也解释了为什么在某些情况下，全局方法可以实现比局部方法更高的压缩率 —— 它们能够捕捉和利用更大范围内的信息冗余。\n\n如果您想进一步探讨某个具体方法如何与香农极限相关，或者讨论在特定场景下如何最佳地应用这些概念，我很乐意继续深入分析。\n</code></pre>\n<hr />\n<h4 id=\"q4-what-are-the-widely-accepted-definitions-and-relevant-literature-for-traditional-compression-methods-and-chunking-methods\"><a class=\"anchor\" href=\"#q4-what-are-the-widely-accepted-definitions-and-relevant-literature-for-traditional-compression-methods-and-chunking-methods\">#</a> Q4: What are the widely accepted definitions and relevant literature for traditional compression methods and chunking methods?</h4>\n<pre><code>有比较公认的，对传统方法和chunking方法的起名，定义或是相关文献吗\n</code></pre>\n<h4 id=\"a4\"><a class=\"anchor\" href=\"#a4\">#</a> A4:</h4>\n<pre><code>确实有一些比较公认的术语和相关文献来描述这两种方法。让我为您总结一下：\n\n1. 传统方法\n\n通常被称为：\n- 数据压缩 (Data Compression)\n- 通用压缩 (General-purpose Compression)\n- 流压缩 (Stream Compression)\n\n主要算法和技术：\n- LZ77/LZ78 系列\n- Huffman 编码\n- 算术编码\n- 字典编码\n\n重要文献：\n- Ziv, J., &amp; Lempel, A. (1977). A universal algorithm for sequential data compression. IEEE Transactions on Information Theory, 23(3), 337-343.\n- Huffman, D. A. (1952). A Method for the Construction of Minimum-Redundancy Codes. Proceedings of the IRE, 40(9), 1098-1101.\n\n2. Chunking 方法\n\n通常被称为：\n- 数据去重 (Data Deduplication)\n- 内容定义分块 (Content-Defined Chunking)\n- 重复数据删除 (Redundancy Elimination)\n\n主要算法和技术：\n- 固定大小分块 (Fixed-size Chunking)\n- 内容定义分块 (Content-Defined Chunking)\n- 滚动哈希 (Rolling Hash)\n- Rabin fingerprint\n\n重要文献：\n- Muthitacharoen, A., Chen, B., &amp; Mazieres, D. (2001). A low-bandwidth network file system. ACM SIGOPS Operating Systems Review, 35(5), 174-187.\n- Quinlan, S., &amp; Dorward, S. (2002). Venti: A New Approach to Archival Storage. In FAST (Vol. 2, pp. 89-101).\n\n3. 比较和综合\n\n一些文献对这两种方法进行了比较和综合：\n\n- Meister, D., &amp; Brinkmann, A. (2009). Multi-level comparison of data deduplication in a backup scenario. In Proceedings of SYSTOR 2009: The Israeli Experimental Systems Conference (pp. 1-12).\n\n- Paulo, J., &amp; Pereira, J. (2014). A survey and classification of storage deduplication systems. ACM Computing Surveys (CSUR), 47(1), 1-30.\n\n4. 新兴领域\n\n近年来，一些新的研究方向结合了这两种方法的特点：\n\n- 压缩去重 (Compression-aware Deduplication)\n- 学习型压缩 (Learned Compression)\n\n相关文献：\n- Xia, W., Jiang, H., Feng, D., &amp; Hua, Y. (2016). Similarity and locality based indexing for high performance data deduplication. IEEE Transactions on Computers, 65(4), 1162-1176.\n\n- Kraska, T., Beutel, A., Chi, E. H., Dean, J., &amp; Polyzotis, N. (2018). The case for learned index structures. In Proceedings of the 2018 International Conference on Management of Data (pp. 489-504).\n\n这些术语和文献提供了一个良好的起点，可以深入了解这两种方法的理论基础、实际应用和最新发展。传统压缩方法起源较早，有大量经典文献；而chunking和去重技术则相对较新，文献主要集中在过去二十年。\n\n如果您对某个特定领域或技术感兴趣，我可以提供更具体的文献建议。\n</code></pre>\n<hr />\n<h4 id=\"q5-in-specific-dataset-scenarios-does-the-chunking-method-break-shannons-compression-limit\"><a class=\"anchor\" href=\"#q5-in-specific-dataset-scenarios-does-the-chunking-method-break-shannons-compression-limit\">#</a> Q5: In specific dataset scenarios, does the chunking method break Shannon's compression limit?</h4>\n<pre><code>我举个例子，数据集为64TiB，我chunking为每个块8MiB，块内字节非常随机，但块和块之前完全相同。在这种情况下传统无损压缩是遵循香农压缩极限的，但chunking类方法完全可以去重至只剩8MiB+许多recipe。这是否是突破了香农极限呢\n</code></pre>\n<h4 id=\"a5\"><a class=\"anchor\" href=\"#a5\">#</a> A5:</h4>\n<pre><code>您提出了一个非常有趣且富有洞察力的例子。这个例子很好地说明了传统压缩方法和基于chunking的去重方法在特定情况下的巨大差异。让我们深入分析这个情况：\n\n1. 传统无损压缩的表现\n\n在这种情况下，传统的无损压缩（如LZ77+Huffman）确实会受到香农压缩极限的限制：\n\n- 由于每个8MiB块内的字节是非常随机的，传统压缩算法可能无法有效压缩单个块。\n- 传统算法通常使用有限的滑动窗口（如32KB），无法捕捉到不同块之间的相似性。\n\n因此，传统方法可能只能实现很小的压缩率，接近于随机数据的香农熵极限。\n\n2. Chunking方法的表现\n\n使用chunking方法，情况就完全不同了：\n\n- 每个8MiB的块都会被识别为完全相同的。\n- 理论上，可以将64TiB的数据压缩到只有一个8MiB的块加上指向这个块的引用（recipe）。\n\n3. 是否突破了香农极限？\n\n从表面上看，chunking方法似乎&quot;突破&quot;了香农极限。但实际上，这并非突破，而是对信息源的不同理解和建模：\n\na) 信息源的重新定义：\n   - 传统方法将每个字节或小块看作独立的信息单元。\n   - Chunking方法将整个8MiB块视为一个信息单元。\n\nb) 条件熵的应用：\n   - 在chunking的视角下，给定第一个8MiB块，后续所有块的条件熵为零。\n   - 这符合香农的信息论原理，只是应用在了更大的尺度上。\n\nc) 元数据（Recipe）的角色：\n   - Recipe 本身也是数据，需要被计入总的数据量。\n   - Recipe 的大小也受到信息论限制，但相对于原始数据可能很小。\n\n4. 正确理解香农极限\n\n香农极限并没有被突破，而是被在更大的尺度上正确应用了：\n\n- 如果我们将整个64TiB数据视为一个整体，其实际熵非常低（因为只有8MiB的唯一信息）。\n- Chunking方法成功捕捉到了这种大尺度的低熵特性。\n\n5. 关键洞察\n\n这个例子揭示了几个重要观点：\n\na) 尺度的重要性：信息论原理可以在不同尺度上应用，选择合适的尺度至关重要。\n\nb) 模型的适应性：有效的压缩需要选择能够最好地捕捉数据实际特性的模型。\n\nc) 全局vs局部优化：有时全局视角可以发现局部方法无法捕捉的模式。\n\nd) 压缩的本质：真正高效的压缩是找到数据的最简洁表示，而不仅仅是局部的模式匹配。\n\n结论：\nchunking方法在这个例子中的惊人效果并不是突破了香农极限，而是更好地应用了信息论原理。它成功地在更大的尺度上捕捉到了数据的真实熵，这是传统方法因其局限性而无法做到的。\n\n这个例子完美地展示了为什么在某些场景下（如备份系统）chunking和去重技术能够实现如此高的压缩率。它也说明了为什么在设计压缩系统时，理解数据的实际结构和选择合适的压缩策略如此重要。\n</code></pre>\n<hr />\n"},{"title":"Feature-based Delta Summary","date":"2024-07-30T16:50:44.000Z","_content":"## Fearture-based  Delta共性\n\n### Delta Compression 系统流程图\n![image.png](https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291513831.png)\nDeduplication能过滤掉重复块，即savesize为0，只留下一个recipe大小的存储开销用于日后恢复。所以需要计算SF并去查SFindex表的块都是已经用FP去重过滤后得到的unique chunk。后续会详细介绍独属于对unique chunk的处理，这部分是delta compression system比只去重系统要增加的部分。\n\n### Fearture-based 通用的流程图\n\n![image.png](https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291506456.png)\n每个独特快都要计算SF(若干个ori feature经过线性变换后得到的1个新的feature叫做super feature)，先拿去查表，有相似块的话做delta compression，没有的话把算好的SF插入SFindex中即可，那之后对当前块做local compression后持久化。\n### SF-index相关 的通用流程图\n![image.png](https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291526625.png)\n再将需要实现的部分总结并抽象出来，发现实际上不同feature-based方法的核心与差异在于SF的计算（Rolling hash，Linear transform）这个方法，此外还要根据SFindex的结构再去实现SF_Find, SF_insert这两个方法。故在实现不同的feature-based方法时重点实现这三个函数，其余很多部分可以复用。\n\n## SF Methods\n\n### N-transform-SF\n开山之作，作者写的很随意，拿和同事的对话当引言，真正意义上的master piece，去看原文吧。\n实现要点：\n- Rolling hash: **Rabin 指纹**去算滚动哈希，对同一个块用12套参数(a,b)求得12个不同的原始特征ori feature\n- Linear transform:将12个ori feature分3组，线性变换为3个SF，存储在三个哈希表中。\n- 压缩效果较好，时间开销极大\n![image.png](https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291744198.png)\n\n### Finesse\n经常被拿来对比的经典作。\n实现要点：\n- Rolling hash: **Rabin 指纹**去算滚动哈希，将一个chunk分为12个subchunk，那之后用同1套参数对每个subchunk求1个ori feature，这样合计12个ori feature。//只有Finesse做了分子块这个操作，有个隐形的限制是原始块不能小于一定值，这个值是其他方法的12倍大小，对chunking方式有一定限制。\n- Linear transform:将12个ori feature先组内排序，再分3组，线性变换为3个SF，存储在三个哈希表中。\n-  压缩效果较差，时间开销减少一些\n![image.png](https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291744886.png)\n\n### Odess\n在压缩效果和计算开销上都非常务实的作品，但可惜行文中自己的工作量不太够，没能中更好的期刊。\n实现要点：\n- Rolling hash: **Gear 滚动哈希+CDS抽样**去算滚动哈希，利用CDS使得只用对1/128个基于内容而定的窗口计算哈希值，虽然对同一个块用12套参数(a,b)求得12个不同的原始特征ori feature，但因为是抽样计算，所以耗时比finesse还要短。\n- Linear transform:将12个ori feature分3组，线性变换为3个SF，存储在三个哈希表中。\n-  压缩效果较好，时间开销减少更多\n![image.png](https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291747134.png)\n\n### Palantir\n提出了一些观点值得思考，但工程角度的总体评价远不如Odess\n实现要点：\n- Rolling hash: **Gear 滚动哈希+CDS抽样**去算滚动哈希，利用CDS使得只用对1/128个基于内容而定的窗口计算哈希值，虽然对同一个块用12套参数(a,b)求得12个不同的原始特征ori feature，但因为是抽样计算，所以耗时比finesse还要短。\n- Linear transform:将12个ori feature分3组，线性变换为3个SF，存储在3个哈希表中。第二层：将12个ori feature分4组，线性变换为4个SF，存储在4个哈希表中。第三层：将12个ori feature分4组，线性变换为6个SF，存储在6个哈希表中。合计13个index。//更多的空间开销和计算开销\n- 为减少每个unique chunk有13个SFindex的开销，推出了生命周期机制，第二层的index在插入5个版本后清除，第三层的index在插入2个版本后清除。//更多的计算开销。\n- 因清除的存在，palantir提出该设计下需要给重复块也计算SF，来查询是否需要补充第2、3层的SFindex。//更多的计算开销\n-  压缩效果短期非常好，长期效果非常差，时间开销极其多。\n\n## Conclusion\n大部分改进delta compression的论文都是从改进本章节SF的计算与选择出发的，改进的指标会是吞吐量或者overall compression ratio。\n不同的SF组装方法，本质是设计了一个不同相似度阈值，较过低或过高都会有损压缩率。每个块及以其作base的delta chunk的最优阈值是不同的，每个数据集更是不同。当然在小数据集上降低阈值寻找更多的相似块是有利于overall ratio的。\n而palantir看似设计了多个阈值，但长远来看还是降低了阈值，在追求optimal overall ratio的道路上这是有害的。\n\n","source":"_posts/Feature-based-Delta-Summary.md","raw":"---\ntitle: Feature-based Delta Summary\ndate: 2024-07-31 00:50:44\ntags:\n  - Feature-based\n  - Compression\n  - Storage system\n  - Operating system\n  - Computer science\ncategories:\n  - Compression algorithms\n---\n## Fearture-based  Delta共性\n\n### Delta Compression 系统流程图\n![image.png](https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291513831.png)\nDeduplication能过滤掉重复块，即savesize为0，只留下一个recipe大小的存储开销用于日后恢复。所以需要计算SF并去查SFindex表的块都是已经用FP去重过滤后得到的unique chunk。后续会详细介绍独属于对unique chunk的处理，这部分是delta compression system比只去重系统要增加的部分。\n\n### Fearture-based 通用的流程图\n\n![image.png](https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291506456.png)\n每个独特快都要计算SF(若干个ori feature经过线性变换后得到的1个新的feature叫做super feature)，先拿去查表，有相似块的话做delta compression，没有的话把算好的SF插入SFindex中即可，那之后对当前块做local compression后持久化。\n### SF-index相关 的通用流程图\n![image.png](https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291526625.png)\n再将需要实现的部分总结并抽象出来，发现实际上不同feature-based方法的核心与差异在于SF的计算（Rolling hash，Linear transform）这个方法，此外还要根据SFindex的结构再去实现SF_Find, SF_insert这两个方法。故在实现不同的feature-based方法时重点实现这三个函数，其余很多部分可以复用。\n\n## SF Methods\n\n### N-transform-SF\n开山之作，作者写的很随意，拿和同事的对话当引言，真正意义上的master piece，去看原文吧。\n实现要点：\n- Rolling hash: **Rabin 指纹**去算滚动哈希，对同一个块用12套参数(a,b)求得12个不同的原始特征ori feature\n- Linear transform:将12个ori feature分3组，线性变换为3个SF，存储在三个哈希表中。\n- 压缩效果较好，时间开销极大\n![image.png](https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291744198.png)\n\n### Finesse\n经常被拿来对比的经典作。\n实现要点：\n- Rolling hash: **Rabin 指纹**去算滚动哈希，将一个chunk分为12个subchunk，那之后用同1套参数对每个subchunk求1个ori feature，这样合计12个ori feature。//只有Finesse做了分子块这个操作，有个隐形的限制是原始块不能小于一定值，这个值是其他方法的12倍大小，对chunking方式有一定限制。\n- Linear transform:将12个ori feature先组内排序，再分3组，线性变换为3个SF，存储在三个哈希表中。\n-  压缩效果较差，时间开销减少一些\n![image.png](https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291744886.png)\n\n### Odess\n在压缩效果和计算开销上都非常务实的作品，但可惜行文中自己的工作量不太够，没能中更好的期刊。\n实现要点：\n- Rolling hash: **Gear 滚动哈希+CDS抽样**去算滚动哈希，利用CDS使得只用对1/128个基于内容而定的窗口计算哈希值，虽然对同一个块用12套参数(a,b)求得12个不同的原始特征ori feature，但因为是抽样计算，所以耗时比finesse还要短。\n- Linear transform:将12个ori feature分3组，线性变换为3个SF，存储在三个哈希表中。\n-  压缩效果较好，时间开销减少更多\n![image.png](https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291747134.png)\n\n### Palantir\n提出了一些观点值得思考，但工程角度的总体评价远不如Odess\n实现要点：\n- Rolling hash: **Gear 滚动哈希+CDS抽样**去算滚动哈希，利用CDS使得只用对1/128个基于内容而定的窗口计算哈希值，虽然对同一个块用12套参数(a,b)求得12个不同的原始特征ori feature，但因为是抽样计算，所以耗时比finesse还要短。\n- Linear transform:将12个ori feature分3组，线性变换为3个SF，存储在3个哈希表中。第二层：将12个ori feature分4组，线性变换为4个SF，存储在4个哈希表中。第三层：将12个ori feature分4组，线性变换为6个SF，存储在6个哈希表中。合计13个index。//更多的空间开销和计算开销\n- 为减少每个unique chunk有13个SFindex的开销，推出了生命周期机制，第二层的index在插入5个版本后清除，第三层的index在插入2个版本后清除。//更多的计算开销。\n- 因清除的存在，palantir提出该设计下需要给重复块也计算SF，来查询是否需要补充第2、3层的SFindex。//更多的计算开销\n-  压缩效果短期非常好，长期效果非常差，时间开销极其多。\n\n## Conclusion\n大部分改进delta compression的论文都是从改进本章节SF的计算与选择出发的，改进的指标会是吞吐量或者overall compression ratio。\n不同的SF组装方法，本质是设计了一个不同相似度阈值，较过低或过高都会有损压缩率。每个块及以其作base的delta chunk的最优阈值是不同的，每个数据集更是不同。当然在小数据集上降低阈值寻找更多的相似块是有利于overall ratio的。\n而palantir看似设计了多个阈值，但长远来看还是降低了阈值，在追求optimal overall ratio的道路上这是有害的。\n\n","slug":"Feature-based-Delta-Summary","published":1,"updated":"2024-07-30T16:51:52.222Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm06vvh0y000124unhrqu61np","content":"<h2 id=\"fearture-based-delta共性\"><a class=\"anchor\" href=\"#fearture-based-delta共性\">#</a> Fearture-based  Delta 共性</h2>\n<h3 id=\"delta-compression-系统流程图\"><a class=\"anchor\" href=\"#delta-compression-系统流程图\">#</a> Delta Compression 系统流程图</h3>\n<p><img data-src=\"https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291513831.png\" alt=\"image.png\" /><br />\nDeduplication 能过滤掉重复块，即 savesize 为 0，只留下一个 recipe 大小的存储开销用于日后恢复。所以需要计算 SF 并去查 SFindex 表的块都是已经用 FP 去重过滤后得到的 unique chunk。后续会详细介绍独属于对 unique chunk 的处理，这部分是 delta compression system 比只去重系统要增加的部分。</p>\n<h3 id=\"fearture-based-通用的流程图\"><a class=\"anchor\" href=\"#fearture-based-通用的流程图\">#</a> Fearture-based 通用的流程图</h3>\n<p><img data-src=\"https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291506456.png\" alt=\"image.png\" /><br />\n 每个独特快都要计算 SF (若干个 ori feature 经过线性变换后得到的 1 个新的 feature 叫做 super feature)，先拿去查表，有相似块的话做 delta compression，没有的话把算好的 SF 插入 SFindex 中即可，那之后对当前块做 local compression 后持久化。</p>\n<h3 id=\"sf-index相关-的通用流程图\"><a class=\"anchor\" href=\"#sf-index相关-的通用流程图\">#</a> SF-index 相关 的通用流程图</h3>\n<p><img data-src=\"https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291526625.png\" alt=\"image.png\" /><br />\n 再将需要实现的部分总结并抽象出来，发现实际上不同 feature-based 方法的核心与差异在于 SF 的计算（Rolling hash，Linear transform）这个方法，此外还要根据 SFindex 的结构再去实现 SF_Find, SF_insert 这两个方法。故在实现不同的 feature-based 方法时重点实现这三个函数，其余很多部分可以复用。</p>\n<h2 id=\"sf-methods\"><a class=\"anchor\" href=\"#sf-methods\">#</a> SF Methods</h2>\n<h3 id=\"n-transform-sf\"><a class=\"anchor\" href=\"#n-transform-sf\">#</a> N-transform-SF</h3>\n<p>开山之作，作者写的很随意，拿和同事的对话当引言，真正意义上的 master piece，去看原文吧。<br />\n实现要点：</p>\n<ul>\n<li>Rolling hash: <strong>Rabin 指纹</strong>去算滚动哈希，对同一个块用 12 套参数 (a,b) 求得 12 个不同的原始特征 ori feature</li>\n<li>Linear transform: 将 12 个 ori feature 分 3 组，线性变换为 3 个 SF，存储在三个哈希表中。</li>\n<li>压缩效果较好，时间开销极大<br />\n<img data-src=\"https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291744198.png\" alt=\"image.png\" /></li>\n</ul>\n<h3 id=\"finesse\"><a class=\"anchor\" href=\"#finesse\">#</a> Finesse</h3>\n<p>经常被拿来对比的经典作。<br />\n实现要点：</p>\n<ul>\n<li>Rolling hash: <strong>Rabin 指纹</strong>去算滚动哈希，将一个 chunk 分为 12 个 subchunk，那之后用同 1 套参数对每个 subchunk 求 1 个 ori feature，这样合计 12 个 ori feature。// 只有 Finesse 做了分子块这个操作，有个隐形的限制是原始块不能小于一定值，这个值是其他方法的 12 倍大小，对 chunking 方式有一定限制。</li>\n<li>Linear transform: 将 12 个 ori feature 先组内排序，再分 3 组，线性变换为 3 个 SF，存储在三个哈希表中。</li>\n<li>压缩效果较差，时间开销减少一些<br />\n<img data-src=\"https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291744886.png\" alt=\"image.png\" /></li>\n</ul>\n<h3 id=\"odess\"><a class=\"anchor\" href=\"#odess\">#</a> Odess</h3>\n<p>在压缩效果和计算开销上都非常务实的作品，但可惜行文中自己的工作量不太够，没能中更好的期刊。<br />\n实现要点：</p>\n<ul>\n<li>Rolling hash: <strong>Gear 滚动哈希 + CDS 抽样</strong>去算滚动哈希，利用 CDS 使得只用对 1/128 个基于内容而定的窗口计算哈希值，虽然对同一个块用 12 套参数 (a,b) 求得 12 个不同的原始特征 ori feature，但因为是抽样计算，所以耗时比 finesse 还要短。</li>\n<li>Linear transform: 将 12 个 ori feature 分 3 组，线性变换为 3 个 SF，存储在三个哈希表中。</li>\n<li>压缩效果较好，时间开销减少更多<br />\n<img data-src=\"https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291747134.png\" alt=\"image.png\" /></li>\n</ul>\n<h3 id=\"palantir\"><a class=\"anchor\" href=\"#palantir\">#</a> Palantir</h3>\n<p>提出了一些观点值得思考，但工程角度的总体评价远不如 Odess<br />\n 实现要点：</p>\n<ul>\n<li>Rolling hash: <strong>Gear 滚动哈希 + CDS 抽样</strong>去算滚动哈希，利用 CDS 使得只用对 1/128 个基于内容而定的窗口计算哈希值，虽然对同一个块用 12 套参数 (a,b) 求得 12 个不同的原始特征 ori feature，但因为是抽样计算，所以耗时比 finesse 还要短。</li>\n<li>Linear transform: 将 12 个 ori feature 分 3 组，线性变换为 3 个 SF，存储在 3 个哈希表中。第二层：将 12 个 ori feature 分 4 组，线性变换为 4 个 SF，存储在 4 个哈希表中。第三层：将 12 个 ori feature 分 4 组，线性变换为 6 个 SF，存储在 6 个哈希表中。合计 13 个 index。// 更多的空间开销和计算开销</li>\n<li>为减少每个 unique chunk 有 13 个 SFindex 的开销，推出了生命周期机制，第二层的 index 在插入 5 个版本后清除，第三层的 index 在插入 2 个版本后清除。// 更多的计算开销。</li>\n<li>因清除的存在，palantir 提出该设计下需要给重复块也计算 SF，来查询是否需要补充第 2、3 层的 SFindex。// 更多的计算开销</li>\n<li>压缩效果短期非常好，长期效果非常差，时间开销极其多。</li>\n</ul>\n<h2 id=\"conclusion\"><a class=\"anchor\" href=\"#conclusion\">#</a> Conclusion</h2>\n<p>大部分改进 delta compression 的论文都是从改进本章节 SF 的计算与选择出发的，改进的指标会是吞吐量或者 overall compression ratio。<br />\n不同的 SF 组装方法，本质是设计了一个不同相似度阈值，较过低或过高都会有损压缩率。每个块及以其作 base 的 delta chunk 的最优阈值是不同的，每个数据集更是不同。当然在小数据集上降低阈值寻找更多的相似块是有利于 overall ratio 的。<br />\n而 palantir 看似设计了多个阈值，但长远来看还是降低了阈值，在追求 optimal overall ratio 的道路上这是有害的。</p>\n","site":{"data":{}},"length":2101,"excerpt":"","more":"<h2 id=\"fearture-based-delta共性\"><a class=\"anchor\" href=\"#fearture-based-delta共性\">#</a> Fearture-based  Delta 共性</h2>\n<h3 id=\"delta-compression-系统流程图\"><a class=\"anchor\" href=\"#delta-compression-系统流程图\">#</a> Delta Compression 系统流程图</h3>\n<p><img data-src=\"https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291513831.png\" alt=\"image.png\" /><br />\nDeduplication 能过滤掉重复块，即 savesize 为 0，只留下一个 recipe 大小的存储开销用于日后恢复。所以需要计算 SF 并去查 SFindex 表的块都是已经用 FP 去重过滤后得到的 unique chunk。后续会详细介绍独属于对 unique chunk 的处理，这部分是 delta compression system 比只去重系统要增加的部分。</p>\n<h3 id=\"fearture-based-通用的流程图\"><a class=\"anchor\" href=\"#fearture-based-通用的流程图\">#</a> Fearture-based 通用的流程图</h3>\n<p><img data-src=\"https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291506456.png\" alt=\"image.png\" /><br />\n 每个独特快都要计算 SF (若干个 ori feature 经过线性变换后得到的 1 个新的 feature 叫做 super feature)，先拿去查表，有相似块的话做 delta compression，没有的话把算好的 SF 插入 SFindex 中即可，那之后对当前块做 local compression 后持久化。</p>\n<h3 id=\"sf-index相关-的通用流程图\"><a class=\"anchor\" href=\"#sf-index相关-的通用流程图\">#</a> SF-index 相关 的通用流程图</h3>\n<p><img data-src=\"https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291526625.png\" alt=\"image.png\" /><br />\n 再将需要实现的部分总结并抽象出来，发现实际上不同 feature-based 方法的核心与差异在于 SF 的计算（Rolling hash，Linear transform）这个方法，此外还要根据 SFindex 的结构再去实现 SF_Find, SF_insert 这两个方法。故在实现不同的 feature-based 方法时重点实现这三个函数，其余很多部分可以复用。</p>\n<h2 id=\"sf-methods\"><a class=\"anchor\" href=\"#sf-methods\">#</a> SF Methods</h2>\n<h3 id=\"n-transform-sf\"><a class=\"anchor\" href=\"#n-transform-sf\">#</a> N-transform-SF</h3>\n<p>开山之作，作者写的很随意，拿和同事的对话当引言，真正意义上的 master piece，去看原文吧。<br />\n实现要点：</p>\n<ul>\n<li>Rolling hash: <strong>Rabin 指纹</strong>去算滚动哈希，对同一个块用 12 套参数 (a,b) 求得 12 个不同的原始特征 ori feature</li>\n<li>Linear transform: 将 12 个 ori feature 分 3 组，线性变换为 3 个 SF，存储在三个哈希表中。</li>\n<li>压缩效果较好，时间开销极大<br />\n<img data-src=\"https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291744198.png\" alt=\"image.png\" /></li>\n</ul>\n<h3 id=\"finesse\"><a class=\"anchor\" href=\"#finesse\">#</a> Finesse</h3>\n<p>经常被拿来对比的经典作。<br />\n实现要点：</p>\n<ul>\n<li>Rolling hash: <strong>Rabin 指纹</strong>去算滚动哈希，将一个 chunk 分为 12 个 subchunk，那之后用同 1 套参数对每个 subchunk 求 1 个 ori feature，这样合计 12 个 ori feature。// 只有 Finesse 做了分子块这个操作，有个隐形的限制是原始块不能小于一定值，这个值是其他方法的 12 倍大小，对 chunking 方式有一定限制。</li>\n<li>Linear transform: 将 12 个 ori feature 先组内排序，再分 3 组，线性变换为 3 个 SF，存储在三个哈希表中。</li>\n<li>压缩效果较差，时间开销减少一些<br />\n<img data-src=\"https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291744886.png\" alt=\"image.png\" /></li>\n</ul>\n<h3 id=\"odess\"><a class=\"anchor\" href=\"#odess\">#</a> Odess</h3>\n<p>在压缩效果和计算开销上都非常务实的作品，但可惜行文中自己的工作量不太够，没能中更好的期刊。<br />\n实现要点：</p>\n<ul>\n<li>Rolling hash: <strong>Gear 滚动哈希 + CDS 抽样</strong>去算滚动哈希，利用 CDS 使得只用对 1/128 个基于内容而定的窗口计算哈希值，虽然对同一个块用 12 套参数 (a,b) 求得 12 个不同的原始特征 ori feature，但因为是抽样计算，所以耗时比 finesse 还要短。</li>\n<li>Linear transform: 将 12 个 ori feature 分 3 组，线性变换为 3 个 SF，存储在三个哈希表中。</li>\n<li>压缩效果较好，时间开销减少更多<br />\n<img data-src=\"https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407291747134.png\" alt=\"image.png\" /></li>\n</ul>\n<h3 id=\"palantir\"><a class=\"anchor\" href=\"#palantir\">#</a> Palantir</h3>\n<p>提出了一些观点值得思考，但工程角度的总体评价远不如 Odess<br />\n 实现要点：</p>\n<ul>\n<li>Rolling hash: <strong>Gear 滚动哈希 + CDS 抽样</strong>去算滚动哈希，利用 CDS 使得只用对 1/128 个基于内容而定的窗口计算哈希值，虽然对同一个块用 12 套参数 (a,b) 求得 12 个不同的原始特征 ori feature，但因为是抽样计算，所以耗时比 finesse 还要短。</li>\n<li>Linear transform: 将 12 个 ori feature 分 3 组，线性变换为 3 个 SF，存储在 3 个哈希表中。第二层：将 12 个 ori feature 分 4 组，线性变换为 4 个 SF，存储在 4 个哈希表中。第三层：将 12 个 ori feature 分 4 组，线性变换为 6 个 SF，存储在 6 个哈希表中。合计 13 个 index。// 更多的空间开销和计算开销</li>\n<li>为减少每个 unique chunk 有 13 个 SFindex 的开销，推出了生命周期机制，第二层的 index 在插入 5 个版本后清除，第三层的 index 在插入 2 个版本后清除。// 更多的计算开销。</li>\n<li>因清除的存在，palantir 提出该设计下需要给重复块也计算 SF，来查询是否需要补充第 2、3 层的 SFindex。// 更多的计算开销</li>\n<li>压缩效果短期非常好，长期效果非常差，时间开销极其多。</li>\n</ul>\n<h2 id=\"conclusion\"><a class=\"anchor\" href=\"#conclusion\">#</a> Conclusion</h2>\n<p>大部分改进 delta compression 的论文都是从改进本章节 SF 的计算与选择出发的，改进的指标会是吞吐量或者 overall compression ratio。<br />\n不同的 SF 组装方法，本质是设计了一个不同相似度阈值，较过低或过高都会有损压缩率。每个块及以其作 base 的 delta chunk 的最优阈值是不同的，每个数据集更是不同。当然在小数据集上降低阈值寻找更多的相似块是有利于 overall ratio 的。<br />\n而 palantir 看似设计了多个阈值，但长远来看还是降低了阈值，在追求 optimal overall ratio 的道路上这是有害的。</p>\n"},{"title":"Chunking summary","date":"2024-07-04T11:48:04.000Z","_content":"\n\n## Chunking flow\n### Flow chart\n\n![image.png](https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407251358457.png)\n### Why only Read part\\\nwe unuslly read 128MiB a time from the Tar to Chunking. this will prevent too much memory from being consumed.\nwhen the ReadFileBuffer is about to reach the end, we need to seekg the next beginning of the buffer.\n\n### Code sample\n```cpp\nvoid Chunker::Chunking()\n{\n    bool end = false;\n    uint32_t totalOffset = 0;\n    while (!end)\n    {\n        memset((char *)readFileBuffer, 0, sizeof(uint8_t) * READ_FILE_SIZE);\n        inputFile.read((char *)readFileBuffer, sizeof(uint8_t) * READ_FILE_SIZE);\n        end = inputFile.eof();\n        size_t len = inputFile.gcount();\n        if (len == 0)\n        {\n            break;\n        }\n        localOffset = 0;\n        while (((len - localOffset) >= MAXCHUNKSIZE) || (end && (localOffset < len)))\n        {\n            Chunk_t chunk;\n            uint32_t cp = 0;\n            cp = CutPoint(readFileBuffer + localOffset, len - localOffset);\n            chunk.chunkPtr = (uint8_t *)malloc(cp);\n            memcpy(chunk.chunkPtr, readFileBuffer + localOffset, cp);\n            chunk.chunkSize = cp;\n            localOffset += cp;\n        }\n        totalOffset += localOffset;\n        inputFile.seekg(totalOffset, ios_base::beg);\n    }\n    return;\n}\n```\n\n## Chunking methods\n\nthe different  chunking methods are reflected in the way cp is obtained. \n```cpp\nuint32_t cp = Chunking(); \n```\n\n### Fixed-size\n\nAs a tradeoff between Deduplication and throughput, chunking methods typically use 8KiB as the desired average size.\n```cpp\nuint32_t Chunker::FixedSize(){\n\t\treturn FixedChunkSize;\n}\n```\nBut the fixed-size chunking will encounter a very serious boundary migration problem, which will allow the reactivity to drop.\n### CDC\nWhen the sliding hash in the window is equal to 0 with the mask that operation set in advance, it is used as a breakpoint.This is called content-defined chunking.\n```cpp\nuint32_t Chunker::CutPointCDC(const uint8_t *src, const uint32_t len)\n{\n    uint32_t fp = 0;\n    uint32_t i = 0;\n    for (; i < len; i++)\n    {\n        fp = fp - Rabin[src[i-windowSize]] + Rabin[src[i]];\n        if (!(fp & MASK_GEAR))\n        {\n            return (i + 1);\n        }\n    }\n    return i;\n};\n```\nThe expected block size is related to the significant bit 1 of the mask. For example, if I want the block size to be 8KiB on average, then I need 13 1's in the mask.\n### Gear\n\nGear Hash reduces the computational overhead of the rolling hash by fixing the significant bit 1 of the mask to be the least significant bit, so that gear can obtain the rolling hash value by bit operation.\n```cpp\nuint32_t Chunker::CutPointGear(const uint8_t *src, const uint32_t len)\n{\n    uint32_t fp = 0;\n    uint32_t i = 0;\n    for (; i < len; i++)\n    {\n        fp = (fp >> 1) + GEAR[src[i]];\n        if (!(fp & MASK_GEAR))\n        {\n            return (i + 1);\n        }\n    }\n    return i;\n};\n```\n\n### FastCDC\nFastCDC solves two problems, one is to further improve throughput, and the other is to standardize block sizes in the 4KiB-16KiB range. It skips the first 4KiB without having to compute the hash, and its mask is also standardized to be bitwise, so that when it reaches 16KiB, it immediately gets the breakpoint, whether it meets the breakpoint condition or not. In addition, to achieve an average size of 8KiB, he uses different masks to generate breakpoints in 4K-8K and 8K-16K.\n\n```cpp\nuint32_t Chunker::CutPointFastCDC(const uint8_t *src, const uint32_t len)\n{\n    uint32_t n;\n    uint32_t fp = 0;\n    uint32_t i;\n    i = min(len, static_cast<uint32_t>(minChunkSize));\n    n = min(normalSize, len);\n    for (; i < n; i++)\n    {\n        fp = (fp >> 1) + GEAR[src[i]];\n        if (!(fp & maskS))\n        {\n            return (i + 1);\n        }\n    }\n\n    n = min(static_cast<uint32_t>(maxChunkSize), len);\n    for (; i < n; i++)\n    {\n        fp = (fp >> 1) + GEAR[src[i]];\n        if (!(fp & maskL))\n        {\n            return (i + 1);\n        }\n    }\n    return i;\n};\n```\n\n### mTar\nmTar argues that the metadata head of the periodic appearance of tar reduces the Deduplication rate\n```cpp\nvoid MTar(){\n\ttranslate the Tar files to mTar files;\n};\n\nFastCDC();\n\n```\n\n## Conclusion\nThe chunking method is a part of the compression system that determines the theoretical upper bound. If the obtained chunk contains extremely high boundary offset, then the best feature value selection method cannot obtain excellent results.","source":"_posts/Summary of Chunking.md","raw":"---\ntitle: Chunking summary\ndate: 2024-07-04 19:48:04\ntags:\n  - Chunking\n  - Compression\n  - Storage system\n  - Operating system\n  - Computer science\ncategories:\n  - Compression algorithms\n---\n\n\n## Chunking flow\n### Flow chart\n\n![image.png](https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407251358457.png)\n### Why only Read part\\\nwe unuslly read 128MiB a time from the Tar to Chunking. this will prevent too much memory from being consumed.\nwhen the ReadFileBuffer is about to reach the end, we need to seekg the next beginning of the buffer.\n\n### Code sample\n```cpp\nvoid Chunker::Chunking()\n{\n    bool end = false;\n    uint32_t totalOffset = 0;\n    while (!end)\n    {\n        memset((char *)readFileBuffer, 0, sizeof(uint8_t) * READ_FILE_SIZE);\n        inputFile.read((char *)readFileBuffer, sizeof(uint8_t) * READ_FILE_SIZE);\n        end = inputFile.eof();\n        size_t len = inputFile.gcount();\n        if (len == 0)\n        {\n            break;\n        }\n        localOffset = 0;\n        while (((len - localOffset) >= MAXCHUNKSIZE) || (end && (localOffset < len)))\n        {\n            Chunk_t chunk;\n            uint32_t cp = 0;\n            cp = CutPoint(readFileBuffer + localOffset, len - localOffset);\n            chunk.chunkPtr = (uint8_t *)malloc(cp);\n            memcpy(chunk.chunkPtr, readFileBuffer + localOffset, cp);\n            chunk.chunkSize = cp;\n            localOffset += cp;\n        }\n        totalOffset += localOffset;\n        inputFile.seekg(totalOffset, ios_base::beg);\n    }\n    return;\n}\n```\n\n## Chunking methods\n\nthe different  chunking methods are reflected in the way cp is obtained. \n```cpp\nuint32_t cp = Chunking(); \n```\n\n### Fixed-size\n\nAs a tradeoff between Deduplication and throughput, chunking methods typically use 8KiB as the desired average size.\n```cpp\nuint32_t Chunker::FixedSize(){\n\t\treturn FixedChunkSize;\n}\n```\nBut the fixed-size chunking will encounter a very serious boundary migration problem, which will allow the reactivity to drop.\n### CDC\nWhen the sliding hash in the window is equal to 0 with the mask that operation set in advance, it is used as a breakpoint.This is called content-defined chunking.\n```cpp\nuint32_t Chunker::CutPointCDC(const uint8_t *src, const uint32_t len)\n{\n    uint32_t fp = 0;\n    uint32_t i = 0;\n    for (; i < len; i++)\n    {\n        fp = fp - Rabin[src[i-windowSize]] + Rabin[src[i]];\n        if (!(fp & MASK_GEAR))\n        {\n            return (i + 1);\n        }\n    }\n    return i;\n};\n```\nThe expected block size is related to the significant bit 1 of the mask. For example, if I want the block size to be 8KiB on average, then I need 13 1's in the mask.\n### Gear\n\nGear Hash reduces the computational overhead of the rolling hash by fixing the significant bit 1 of the mask to be the least significant bit, so that gear can obtain the rolling hash value by bit operation.\n```cpp\nuint32_t Chunker::CutPointGear(const uint8_t *src, const uint32_t len)\n{\n    uint32_t fp = 0;\n    uint32_t i = 0;\n    for (; i < len; i++)\n    {\n        fp = (fp >> 1) + GEAR[src[i]];\n        if (!(fp & MASK_GEAR))\n        {\n            return (i + 1);\n        }\n    }\n    return i;\n};\n```\n\n### FastCDC\nFastCDC solves two problems, one is to further improve throughput, and the other is to standardize block sizes in the 4KiB-16KiB range. It skips the first 4KiB without having to compute the hash, and its mask is also standardized to be bitwise, so that when it reaches 16KiB, it immediately gets the breakpoint, whether it meets the breakpoint condition or not. In addition, to achieve an average size of 8KiB, he uses different masks to generate breakpoints in 4K-8K and 8K-16K.\n\n```cpp\nuint32_t Chunker::CutPointFastCDC(const uint8_t *src, const uint32_t len)\n{\n    uint32_t n;\n    uint32_t fp = 0;\n    uint32_t i;\n    i = min(len, static_cast<uint32_t>(minChunkSize));\n    n = min(normalSize, len);\n    for (; i < n; i++)\n    {\n        fp = (fp >> 1) + GEAR[src[i]];\n        if (!(fp & maskS))\n        {\n            return (i + 1);\n        }\n    }\n\n    n = min(static_cast<uint32_t>(maxChunkSize), len);\n    for (; i < n; i++)\n    {\n        fp = (fp >> 1) + GEAR[src[i]];\n        if (!(fp & maskL))\n        {\n            return (i + 1);\n        }\n    }\n    return i;\n};\n```\n\n### mTar\nmTar argues that the metadata head of the periodic appearance of tar reduces the Deduplication rate\n```cpp\nvoid MTar(){\n\ttranslate the Tar files to mTar files;\n};\n\nFastCDC();\n\n```\n\n## Conclusion\nThe chunking method is a part of the compression system that determines the theoretical upper bound. If the obtained chunk contains extremely high boundary offset, then the best feature value selection method cannot obtain excellent results.","slug":"Summary of Chunking","published":1,"updated":"2024-07-25T08:54:16.991Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm06vvh18000m24unfnkscfmr","content":"<h2 id=\"chunking-flow\"><a class=\"anchor\" href=\"#chunking-flow\">#</a> Chunking flow</h2>\n<h3 id=\"flow-chart\"><a class=\"anchor\" href=\"#flow-chart\">#</a> Flow chart</h3>\n<p><img data-src=\"https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407251358457.png\" alt=\"image.png\" /></p>\n<h3 id=\"why-only-read-part\"><a class=\"anchor\" href=\"#why-only-read-part\">#</a> Why only Read part\\</h3>\n<p>we unuslly read 128MiB a time from the Tar to Chunking. this will prevent too much memory from being consumed.<br />\nwhen the ReadFileBuffer is about to reach the end, we need to seekg the next beginning of the buffer.</p>\n<h3 id=\"code-sample\"><a class=\"anchor\" href=\"#code-sample\">#</a> Code sample</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token class-name\">Chunker</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">Chunking</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">bool</span> end <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">uint32_t</span> totalOffset <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>end<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token function\">memset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>readFileBuffer<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">uint8_t</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> READ_FILE_SIZE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        inputFile<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>readFileBuffer<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">uint8_t</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> READ_FILE_SIZE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        end <span class=\"token operator\">=</span> inputFile<span class=\"token punctuation\">.</span><span class=\"token function\">eof</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        size_t len <span class=\"token operator\">=</span> inputFile<span class=\"token punctuation\">.</span><span class=\"token function\">gcount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>len <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        localOffset <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>len <span class=\"token operator\">-</span> localOffset<span class=\"token punctuation\">)</span> <span class=\"token operator\">>=</span> MAXCHUNKSIZE<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>end <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>localOffset <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            Chunk_t chunk<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>            <span class=\"token keyword\">uint32_t</span> cp <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>            cp <span class=\"token operator\">=</span> <span class=\"token function\">CutPoint</span><span class=\"token punctuation\">(</span>readFileBuffer <span class=\"token operator\">+</span> localOffset<span class=\"token punctuation\">,</span> len <span class=\"token operator\">-</span> localOffset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            chunk<span class=\"token punctuation\">.</span>chunkPtr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">uint8_t</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span>cp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>            <span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span>chunk<span class=\"token punctuation\">.</span>chunkPtr<span class=\"token punctuation\">,</span> readFileBuffer <span class=\"token operator\">+</span> localOffset<span class=\"token punctuation\">,</span> cp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>            chunk<span class=\"token punctuation\">.</span>chunkSize <span class=\"token operator\">=</span> cp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            localOffset <span class=\"token operator\">+=</span> cp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        totalOffset <span class=\"token operator\">+=</span> localOffset<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        inputFile<span class=\"token punctuation\">.</span><span class=\"token function\">seekg</span><span class=\"token punctuation\">(</span>totalOffset<span class=\"token punctuation\">,</span> ios_base<span class=\"token double-colon punctuation\">::</span>beg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"chunking-methods\"><a class=\"anchor\" href=\"#chunking-methods\">#</a> Chunking methods</h2>\n<p>the different  chunking methods are reflected in the way cp is obtained.</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">uint32_t</span> cp <span class=\"token operator\">=</span> <span class=\"token function\">Chunking</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"fixed-size\"><a class=\"anchor\" href=\"#fixed-size\">#</a> Fixed-size</h3>\n<p>As a tradeoff between Deduplication and throughput, chunking methods typically use 8KiB as the desired average size.</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">uint32_t</span> <span class=\"token class-name\">Chunker</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">FixedSize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t\t<span class=\"token keyword\">return</span> FixedChunkSize<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>But the fixed-size chunking will encounter a very serious boundary migration problem, which will allow the reactivity to drop.</p>\n<h3 id=\"cdc\"><a class=\"anchor\" href=\"#cdc\">#</a> CDC</h3>\n<p>When the sliding hash in the window is equal to 0 with the mask that operation set in advance, it is used as a breakpoint.This is called content-defined chunking.</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">uint32_t</span> <span class=\"token class-name\">Chunker</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">CutPointCDC</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">uint8_t</span> <span class=\"token operator\">*</span>src<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">uint32_t</span> len<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">uint32_t</span> fp <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">uint32_t</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        fp <span class=\"token operator\">=</span> fp <span class=\"token operator\">-</span> Rabin<span class=\"token punctuation\">[</span>src<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span>windowSize<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> Rabin<span class=\"token punctuation\">[</span>src<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>fp <span class=\"token operator\">&amp;</span> MASK_GEAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>The expected block size is related to the significant bit 1 of the mask. For example, if I want the block size to be 8KiB on average, then I need 13 1's in the mask.</p>\n<h3 id=\"gear\"><a class=\"anchor\" href=\"#gear\">#</a> Gear</h3>\n<p>Gear Hash reduces the computational overhead of the rolling hash by fixing the significant bit 1 of the mask to be the least significant bit, so that gear can obtain the rolling hash value by bit operation.</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">uint32_t</span> <span class=\"token class-name\">Chunker</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">CutPointGear</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">uint8_t</span> <span class=\"token operator\">*</span>src<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">uint32_t</span> len<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">uint32_t</span> fp <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">uint32_t</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        fp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>fp <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> GEAR<span class=\"token punctuation\">[</span>src<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>fp <span class=\"token operator\">&amp;</span> MASK_GEAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"fastcdc\"><a class=\"anchor\" href=\"#fastcdc\">#</a> FastCDC</h3>\n<p>FastCDC solves two problems, one is to further improve throughput, and the other is to standardize block sizes in the 4KiB-16KiB range. It skips the first 4KiB without having to compute the hash, and its mask is also standardized to be bitwise, so that when it reaches 16KiB, it immediately gets the breakpoint, whether it meets the breakpoint condition or not. In addition, to achieve an average size of 8KiB, he uses different masks to generate breakpoints in 4K-8K and 8K-16K.</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">uint32_t</span> <span class=\"token class-name\">Chunker</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">CutPointFastCDC</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">uint8_t</span> <span class=\"token operator\">*</span>src<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">uint32_t</span> len<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">uint32_t</span> n<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">uint32_t</span> fp <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">uint32_t</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    i <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>len<span class=\"token punctuation\">,</span> <span class=\"token generic-function\"><span class=\"token function\">static_cast</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token keyword\">uint32_t</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>minChunkSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    n <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>normalSize<span class=\"token punctuation\">,</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        fp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>fp <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> GEAR<span class=\"token punctuation\">[</span>src<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>fp <span class=\"token operator\">&amp;</span> maskS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    n <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span><span class=\"token generic-function\"><span class=\"token function\">static_cast</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token keyword\">uint32_t</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>maxChunkSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        fp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>fp <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> GEAR<span class=\"token punctuation\">[</span>src<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>fp <span class=\"token operator\">&amp;</span> maskL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"mtar\"><a class=\"anchor\" href=\"#mtar\">#</a> mTar</h3>\n<p>mTar argues that the metadata head of the periodic appearance of tar reduces the Deduplication rate</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">MTar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\ttranslate the Tar files to mTar files<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">FastCDC</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h2 id=\"conclusion\"><a class=\"anchor\" href=\"#conclusion\">#</a> Conclusion</h2>\n<p>The chunking method is a part of the compression system that determines the theoretical upper bound. If the obtained chunk contains extremely high boundary offset, then the best feature value selection method cannot obtain excellent results.</p>\n","site":{"data":{}},"length":3387,"excerpt":"","more":"<h2 id=\"chunking-flow\"><a class=\"anchor\" href=\"#chunking-flow\">#</a> Chunking flow</h2>\n<h3 id=\"flow-chart\"><a class=\"anchor\" href=\"#flow-chart\">#</a> Flow chart</h3>\n<p><img data-src=\"https://notepic-1327795028.cos.ap-chengdu.myqcloud.com/pic/202407251358457.png\" alt=\"image.png\" /></p>\n<h3 id=\"why-only-read-part\"><a class=\"anchor\" href=\"#why-only-read-part\">#</a> Why only Read part\\</h3>\n<p>we unuslly read 128MiB a time from the Tar to Chunking. this will prevent too much memory from being consumed.<br />\nwhen the ReadFileBuffer is about to reach the end, we need to seekg the next beginning of the buffer.</p>\n<h3 id=\"code-sample\"><a class=\"anchor\" href=\"#code-sample\">#</a> Code sample</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token class-name\">Chunker</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">Chunking</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">bool</span> end <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">uint32_t</span> totalOffset <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>end<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token function\">memset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>readFileBuffer<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">uint8_t</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> READ_FILE_SIZE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        inputFile<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>readFileBuffer<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">uint8_t</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> READ_FILE_SIZE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        end <span class=\"token operator\">=</span> inputFile<span class=\"token punctuation\">.</span><span class=\"token function\">eof</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        size_t len <span class=\"token operator\">=</span> inputFile<span class=\"token punctuation\">.</span><span class=\"token function\">gcount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>len <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        localOffset <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>len <span class=\"token operator\">-</span> localOffset<span class=\"token punctuation\">)</span> <span class=\"token operator\">>=</span> MAXCHUNKSIZE<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>end <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>localOffset <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            Chunk_t chunk<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>            <span class=\"token keyword\">uint32_t</span> cp <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>            cp <span class=\"token operator\">=</span> <span class=\"token function\">CutPoint</span><span class=\"token punctuation\">(</span>readFileBuffer <span class=\"token operator\">+</span> localOffset<span class=\"token punctuation\">,</span> len <span class=\"token operator\">-</span> localOffset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            chunk<span class=\"token punctuation\">.</span>chunkPtr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">uint8_t</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span>cp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>            <span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span>chunk<span class=\"token punctuation\">.</span>chunkPtr<span class=\"token punctuation\">,</span> readFileBuffer <span class=\"token operator\">+</span> localOffset<span class=\"token punctuation\">,</span> cp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>            chunk<span class=\"token punctuation\">.</span>chunkSize <span class=\"token operator\">=</span> cp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            localOffset <span class=\"token operator\">+=</span> cp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        totalOffset <span class=\"token operator\">+=</span> localOffset<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        inputFile<span class=\"token punctuation\">.</span><span class=\"token function\">seekg</span><span class=\"token punctuation\">(</span>totalOffset<span class=\"token punctuation\">,</span> ios_base<span class=\"token double-colon punctuation\">::</span>beg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"chunking-methods\"><a class=\"anchor\" href=\"#chunking-methods\">#</a> Chunking methods</h2>\n<p>the different  chunking methods are reflected in the way cp is obtained.</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">uint32_t</span> cp <span class=\"token operator\">=</span> <span class=\"token function\">Chunking</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"fixed-size\"><a class=\"anchor\" href=\"#fixed-size\">#</a> Fixed-size</h3>\n<p>As a tradeoff between Deduplication and throughput, chunking methods typically use 8KiB as the desired average size.</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">uint32_t</span> <span class=\"token class-name\">Chunker</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">FixedSize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t\t<span class=\"token keyword\">return</span> FixedChunkSize<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>But the fixed-size chunking will encounter a very serious boundary migration problem, which will allow the reactivity to drop.</p>\n<h3 id=\"cdc\"><a class=\"anchor\" href=\"#cdc\">#</a> CDC</h3>\n<p>When the sliding hash in the window is equal to 0 with the mask that operation set in advance, it is used as a breakpoint.This is called content-defined chunking.</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">uint32_t</span> <span class=\"token class-name\">Chunker</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">CutPointCDC</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">uint8_t</span> <span class=\"token operator\">*</span>src<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">uint32_t</span> len<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">uint32_t</span> fp <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">uint32_t</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        fp <span class=\"token operator\">=</span> fp <span class=\"token operator\">-</span> Rabin<span class=\"token punctuation\">[</span>src<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span>windowSize<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> Rabin<span class=\"token punctuation\">[</span>src<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>fp <span class=\"token operator\">&amp;</span> MASK_GEAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>The expected block size is related to the significant bit 1 of the mask. For example, if I want the block size to be 8KiB on average, then I need 13 1's in the mask.</p>\n<h3 id=\"gear\"><a class=\"anchor\" href=\"#gear\">#</a> Gear</h3>\n<p>Gear Hash reduces the computational overhead of the rolling hash by fixing the significant bit 1 of the mask to be the least significant bit, so that gear can obtain the rolling hash value by bit operation.</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">uint32_t</span> <span class=\"token class-name\">Chunker</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">CutPointGear</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">uint8_t</span> <span class=\"token operator\">*</span>src<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">uint32_t</span> len<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">uint32_t</span> fp <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">uint32_t</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        fp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>fp <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> GEAR<span class=\"token punctuation\">[</span>src<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>fp <span class=\"token operator\">&amp;</span> MASK_GEAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"fastcdc\"><a class=\"anchor\" href=\"#fastcdc\">#</a> FastCDC</h3>\n<p>FastCDC solves two problems, one is to further improve throughput, and the other is to standardize block sizes in the 4KiB-16KiB range. It skips the first 4KiB without having to compute the hash, and its mask is also standardized to be bitwise, so that when it reaches 16KiB, it immediately gets the breakpoint, whether it meets the breakpoint condition or not. In addition, to achieve an average size of 8KiB, he uses different masks to generate breakpoints in 4K-8K and 8K-16K.</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">uint32_t</span> <span class=\"token class-name\">Chunker</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">CutPointFastCDC</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">uint8_t</span> <span class=\"token operator\">*</span>src<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">uint32_t</span> len<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">uint32_t</span> n<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">uint32_t</span> fp <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">uint32_t</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    i <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>len<span class=\"token punctuation\">,</span> <span class=\"token generic-function\"><span class=\"token function\">static_cast</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token keyword\">uint32_t</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>minChunkSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    n <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>normalSize<span class=\"token punctuation\">,</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        fp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>fp <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> GEAR<span class=\"token punctuation\">[</span>src<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>fp <span class=\"token operator\">&amp;</span> maskS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    n <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span><span class=\"token generic-function\"><span class=\"token function\">static_cast</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token keyword\">uint32_t</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>maxChunkSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        fp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>fp <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> GEAR<span class=\"token punctuation\">[</span>src<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>fp <span class=\"token operator\">&amp;</span> maskL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"mtar\"><a class=\"anchor\" href=\"#mtar\">#</a> mTar</h3>\n<p>mTar argues that the metadata head of the periodic appearance of tar reduces the Deduplication rate</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">MTar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\ttranslate the Tar files to mTar files<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">FastCDC</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h2 id=\"conclusion\"><a class=\"anchor\" href=\"#conclusion\">#</a> Conclusion</h2>\n<p>The chunking method is a part of the compression system that determines the theoretical upper bound. If the obtained chunk contains extremely high boundary offset, then the best feature value selection method cannot obtain excellent results.</p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2024-07-22T13:54:25.496Z","updated":"2024-07-22T13:54:25.496Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm06vvh18000n24undrxi2bq8","content":"<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo new <span class=\"token string\">\"My New Post\"</span></pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo server</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo generate</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo deploy</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n","site":{"data":{}},"length":362,"excerpt":"","more":"<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo new <span class=\"token string\">\"My New Post\"</span></pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo server</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo generate</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo deploy</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cm06vvh0y000124unhrqu61np","category_id":"cm06vvh0z000224un648u9lrq","_id":"cm06vvh13000924un03sw2idn"},{"post_id":"cm06vvh0t000024unc7h55g6h","category_id":"cm06vvh0z000224un648u9lrq","_id":"cm06vvh14000c24un59x20acj"},{"post_id":"cm06vvh0t000024unc7h55g6h","category_id":"cm06vvh13000624un82g332ev","_id":"cm06vvh14000e24un5syd3928"},{"post_id":"cm06vvh18000m24unfnkscfmr","category_id":"cm06vvh0z000224un648u9lrq","_id":"cm06vvh19000p24un7zdh8ur0"}],"PostTag":[{"post_id":"cm06vvh0t000024unc7h55g6h","tag_id":"cm06vvh10000324unfywh9ely","_id":"cm06vvh13000824un3eec9l3q"},{"post_id":"cm06vvh0t000024unc7h55g6h","tag_id":"cm06vvh11000524un0yynhg4z","_id":"cm06vvh13000a24unawojan20"},{"post_id":"cm06vvh0y000124unhrqu61np","tag_id":"cm06vvh13000724un47e9gx9e","_id":"cm06vvh15000h24unais145l8"},{"post_id":"cm06vvh0y000124unhrqu61np","tag_id":"cm06vvh10000324unfywh9ely","_id":"cm06vvh15000i24unaaxo4fb2"},{"post_id":"cm06vvh0y000124unhrqu61np","tag_id":"cm06vvh11000524un0yynhg4z","_id":"cm06vvh15000j24un7o0v3wlv"},{"post_id":"cm06vvh0y000124unhrqu61np","tag_id":"cm06vvh14000f24ungx4ebpag","_id":"cm06vvh15000k24un9ejmhv8z"},{"post_id":"cm06vvh0y000124unhrqu61np","tag_id":"cm06vvh15000g24un4beqcjtb","_id":"cm06vvh15000l24un5bm72eho"},{"post_id":"cm06vvh18000m24unfnkscfmr","tag_id":"cm06vvh19000o24un8bl43k43","_id":"cm06vvh19000q24unfkzg2mxj"},{"post_id":"cm06vvh18000m24unfnkscfmr","tag_id":"cm06vvh10000324unfywh9ely","_id":"cm06vvh19000r24un31tu62si"},{"post_id":"cm06vvh18000m24unfnkscfmr","tag_id":"cm06vvh11000524un0yynhg4z","_id":"cm06vvh19000s24un28yt6wv8"},{"post_id":"cm06vvh18000m24unfnkscfmr","tag_id":"cm06vvh14000f24ungx4ebpag","_id":"cm06vvh19000t24un6llnewrl"},{"post_id":"cm06vvh18000m24unfnkscfmr","tag_id":"cm06vvh15000g24un4beqcjtb","_id":"cm06vvh19000u24ungnitdwuv"}],"Tag":[{"name":"Compression","_id":"cm06vvh10000324unfywh9ely"},{"name":"Storage system","_id":"cm06vvh11000524un0yynhg4z"},{"name":"Feature-based","_id":"cm06vvh13000724un47e9gx9e"},{"name":"Operating system","_id":"cm06vvh14000f24ungx4ebpag"},{"name":"Computer science","_id":"cm06vvh15000g24un4beqcjtb"},{"name":"Chunking","_id":"cm06vvh19000o24un8bl43k43"}]}}